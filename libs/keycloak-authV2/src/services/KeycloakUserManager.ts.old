/**
 * Keycloak User Manager Service
 * Handles user management operations using Keycloak Admin API
 *
 * @deprecated This monolithic class has been refactored into a modular SOLID architecture.
 *             Use KeycloakUserService from './user' for new implementations.
 *             See REFACTORING_GUIDE.md for migration instructions.
 *
 * @example Migration Path:
 * ```typescript
 * // OLD (deprecated)
 * const userManager = new KeycloakUserManager(adminClient, config, metrics);
 *
 * // NEW (recommended)
 * import { KeycloakUserService } from "./user";
 * const userService = KeycloakUserService.create(keycloakClient, config, cacheService, metrics);
 * ```
 */

import { createLogger } from "@libs/utils";
import { CacheService } from "@libs/database";
import type { IMetricsCollector } from "@libs/monitoring";
import type { UserInfo } from "../types";
import type { AuthV2Config } from "./token/config";
import {
  KeycloakClient,
  type KeycloakTokenResponse,
} from "../client/KeycloakClient";
import { createHttpClient, HttpStatus, type HttpClient } from "@libs/messaging";

/**
 * Keycloak User Representation
 */
export interface KeycloakUser {
  id?: string | undefined;
  username: string;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  enabled?: boolean | undefined;
  emailVerified?: boolean | undefined;
  createdTimestamp?: number | undefined;
  attributes?: Record<string, string[]> | undefined;
  credentials?: KeycloakCredential[] | undefined;
  realmRoles?: string[] | undefined;
  clientRoles?: Record<string, string[]> | undefined;
}

/**
 * Keycloak User Credential
 */
export interface KeycloakCredential {
  type: string;
  value: string;
  temporary?: boolean;
}

/**
 * Keycloak Role Representation
 */
export interface KeycloakRole {
  id?: string;
  name: string;
  description?: string;
  composite?: boolean;
  clientRole?: boolean;
  containerId?: string;
}

/**
 * User Search Options
 */
export interface UserSearchOptions {
  username?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  search?: string;
  exact?: boolean;
  max?: number;
  first?: number;
}

/**
 * User Creation Options
 */
export interface CreateUserOptions {
  username: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  password?: string;
  temporaryPassword?: boolean;
  enabled?: boolean;
  emailVerified?: boolean;
  attributes?: Record<string, string[]>;
  realmRoles?: string[];
  clientRoles?: Record<string, string[]>;
}

/**
 * User Update Options
 */
export interface UpdateUserOptions {
  email?: string;
  firstName?: string;
  lastName?: string;
  enabled?: boolean;
  emailVerified?: boolean;
  attributes?: Record<string, string[]>;
}

/**
 * Password Reset Options
 */
export interface ResetPasswordOptions {
  password: string;
  temporary?: boolean;
}

/**
 * @deprecated This class is deprecated in favor of the modular SOLID architecture.
 *             Use KeycloakUserService for new implementations.
 */
export class KeycloakUserManager {
  private readonly logger = createLogger("KeycloakUserManager");
  private readonly httpClient: HttpClient;
  private cacheService?: CacheService;
  private adminToken?: KeycloakTokenResponse;
  private tokenExpiry?: Date;

  constructor(
    private readonly adminClient: KeycloakClient,
    private readonly config: AuthV2Config,
    private readonly metrics?: IMetricsCollector
  ) {
    // Initialize HTTP client for Admin API calls
    this.httpClient = createHttpClient({
      timeout: 30000, // 30 seconds for admin operations
      retries: 3,
    });

    // Initialize cache if enabled
    if (this.config.cache.enabled && metrics) {
      this.cacheService = CacheService.create(metrics);
    }
  }

  /**
   * Initialize admin token for API calls
   */
  private async ensureAdminToken(): Promise<string> {
    const now = new Date();

    // Check if we have a valid token
    if (this.adminToken && this.tokenExpiry && now < this.tokenExpiry) {
      return this.adminToken.access_token;
    }

    try {
      // Get new admin token using client credentials
      this.adminToken = await this.adminClient.authenticateClientCredentials([
        "manage-users",
        "manage-realm",
        "view-users",
        "view-realm",
      ]);

      // Calculate expiry (subtract 30 seconds for safety)
      this.tokenExpiry = new Date(
        now.getTime() + (this.adminToken.expires_in - 30) * 1000
      );

      this.logger.debug("Admin token refreshed", {
        expiresIn: this.adminToken.expires_in,
      });

      return this.adminToken.access_token;
    } catch (error) {
      this.logger.error("Failed to obtain admin token", { error });
      throw new Error("Failed to authenticate with Keycloak Admin API");
    }
  }

  /**
   * Get admin API base URL
   */
  private getAdminApiUrl(): string {
    const discoveryDoc = this.adminClient.getDiscoveryDocument();
    if (!discoveryDoc) {
      throw new Error("Keycloak discovery document not available");
    }

    // Extract base URL from issuer
    const baseUrl = discoveryDoc.issuer.replace(/\/realms\/.*$/, "");
    const realm = discoveryDoc.issuer.split("/realms/")[1];

    return `${baseUrl}/admin/realms/${realm}`;
  }

  /**
   * Search for users
   */
  async searchUsers(options: UserSearchOptions): Promise<KeycloakUser[]> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      // Build query parameters
      const params = new URLSearchParams();
      if (options.username) params.append("username", options.username);
      if (options.email) params.append("email", options.email);
      if (options.firstName) params.append("firstName", options.firstName);
      if (options.lastName) params.append("lastName", options.lastName);
      if (options.search) params.append("search", options.search);
      if (options.exact !== undefined)
        params.append("exact", options.exact.toString());
      if (options.max !== undefined)
        params.append("max", options.max.toString());
      if (options.first !== undefined)
        params.append("first", options.first.toString());

      const response = await this.httpClient.get<KeycloakUser[]>(
        `${baseUrl}/users?${params.toString()}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        throw new Error(
          `User search failed: ${response.status} ${response.statusText}`
        );
      }

      const users: KeycloakUser[] = response.data;

      this.metrics?.recordCounter("keycloak.user_manager.search_users", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.search_users_duration",
        performance.now() - startTime
      );

      this.logger.debug("Users searched", {
        count: users.length,
        options,
      });

      return users;
    } catch (error) {
      this.logger.error("User search failed", { error, options });
      this.metrics?.recordCounter(
        "keycloak.user_manager.search_users_error",
        1
      );
      throw error;
    }
  }

  /**
   * Get user by ID
   */
  async getUserById(userId: string): Promise<KeycloakUser | null> {
    const startTime = performance.now();

    try {
      // Check cache first
      if (this.cacheService) {
        const cacheKey = `keycloak_user:${userId}`;
        const cachedUser = await this.cacheService.get<KeycloakUser>(cacheKey);

        if (cachedUser.data) {
          this.metrics?.recordCounter(
            "keycloak.user_manager.get_user_cache_hit",
            1
          );
          return cachedUser.data;
        }

        this.metrics?.recordCounter(
          "keycloak.user_manager.get_user_cache_miss",
          1
        );
      }

      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      const response = await this.httpClient.get<KeycloakUser>(
        `${baseUrl}/users/${userId}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/json",
          },
        }
      );

      if (response.status === 404) {
        return null;
      }

      if (!HttpStatus.isSuccess(response.status)) {
        throw new Error(
          `Get user failed: ${response.status} ${response.statusText}`
        );
      }

      const user: KeycloakUser = response.data;

      // Cache the user
      if (this.cacheService) {
        const cacheKey = `keycloak_user:${userId}`;
        await this.cacheService.set(cacheKey, user, 300); // Cache for 5 minutes
      }

      this.metrics?.recordCounter("keycloak.user_manager.get_user", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.get_user_duration",
        performance.now() - startTime
      );

      return user;
    } catch (error) {
      this.logger.error("Get user failed", { error, userId });
      this.metrics?.recordCounter("keycloak.user_manager.get_user_error", 1);
      throw error;
    }
  }

  /**
   * Get user by username
   */
  async getUserByUsername(username: string): Promise<KeycloakUser | null> {
    try {
      const users = await this.searchUsers({
        username,
        exact: true,
        max: 1,
      });

      return users.length > 0 ? users[0] ?? null : null;
    } catch (error) {
      this.logger.error("Get user by username failed", { error, username });
      throw error;
    }
  }

  /**
   * Create a new user
   */
  async createUser(options: CreateUserOptions): Promise<string> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      // Build user representation
      const user: KeycloakUser = {
        username: options.username,
        email: options.email,
        firstName: options.firstName,
        lastName: options.lastName,
        enabled: options.enabled !== false,
        emailVerified: options.emailVerified || false,
        attributes: options.attributes,
      };

      // Add password credential if provided
      if (options.password) {
        user.credentials = [
          {
            type: "password",
            value: options.password,
            temporary: options.temporaryPassword || false,
          },
        ];
      }

      const response = await this.httpClient.post<KeycloakUser>(
        `${baseUrl}/users`,
        JSON.stringify(user),
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
            Accept: "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `User creation failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      // Extract user ID from Location header
      const locationHeader =
        response.headers?.["location"] || response.headers?.["Location"];
      if (!locationHeader) {
        throw new Error("User created but ID not returned");
      }

      const userId = locationHeader.split("/").pop()!;

      // Assign roles if specified
      if (options.realmRoles?.length) {
        await this.assignRealmRoles(userId, options.realmRoles);
      }

      if (options.clientRoles) {
        for (const [clientId, roles] of Object.entries(options.clientRoles)) {
          if (roles.length > 0) {
            await this.assignClientRoles(userId, clientId, roles);
          }
        }
      }

      this.metrics?.recordCounter("keycloak.user_manager.create_user", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.create_user_duration",
        performance.now() - startTime
      );

      this.logger.info("User created", {
        userId,
        username: options.username,
      });

      return userId;
    } catch (error) {
      this.logger.error("User creation failed", { error, options });
      this.metrics?.recordCounter("keycloak.user_manager.create_user_error", 1);
      throw error;
    }
  }

  /**
   * Update user
   */
  async updateUser(userId: string, options: UpdateUserOptions): Promise<void> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      const response = await this.httpClient.put<KeycloakUser>(
        `${baseUrl}/users/${userId}`,
        JSON.stringify(options),
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `User update failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      // Invalidate cache
      if (this.cacheService) {
        const cacheKey = `keycloak_user:${userId}`;
        await this.cacheService.invalidate(cacheKey);
      }

      this.metrics?.recordCounter("keycloak.user_manager.update_user", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.update_user_duration",
        performance.now() - startTime
      );

      this.logger.info("User updated", { userId });
    } catch (error) {
      this.logger.error("User update failed", { error, userId, options });
      this.metrics?.recordCounter("keycloak.user_manager.update_user_error", 1);
      throw error;
    }
  }

  /**
   * Delete user
   */
  async deleteUser(userId: string): Promise<void> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      const response = await this.httpClient.delete(
        `${baseUrl}/users/${userId}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (response.status === 404) {
        this.logger.warn("User not found for deletion", { userId });
        return;
      }

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `User deletion failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      // Invalidate cache
      if (this.cacheService) {
        const cacheKey = `keycloak_user:${userId}`;
        await this.cacheService.invalidate(cacheKey);
      }

      this.metrics?.recordCounter("keycloak.user_manager.delete_user", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.delete_user_duration",
        performance.now() - startTime
      );

      this.logger.info("User deleted", { userId });
    } catch (error) {
      this.logger.error("User deletion failed", { error, userId });
      this.metrics?.recordCounter("keycloak.user_manager.delete_user_error", 1);
      throw error;
    }
  }

  /**
   * Reset user password
   */
  async resetPassword(
    userId: string,
    options: ResetPasswordOptions
  ): Promise<void> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      const credential: KeycloakCredential = {
        type: "password",
        value: options.password,
        temporary: options.temporary || false,
      };

      const response = await this.httpClient.put(
        `${baseUrl}/users/${userId}/reset-password`,
        JSON.stringify(credential),
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `Password reset failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      this.metrics?.recordCounter("keycloak.user_manager.reset_password", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.reset_password_duration",
        performance.now() - startTime
      );

      this.logger.info("Password reset", {
        userId,
        temporary: options.temporary,
      });
    } catch (error) {
      this.logger.error("Password reset failed", { error, userId });
      this.metrics?.recordCounter(
        "keycloak.user_manager.reset_password_error",
        1
      );
      throw error;
    }
  }

  /**
   * Get user's realm roles
   */
  async getUserRealmRoles(userId: string): Promise<KeycloakRole[]> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      const response = await this.httpClient.get<KeycloakRole[]>(
        `${baseUrl}/users/${userId}/role-mappings/realm`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        throw new Error(
          `Get user realm roles failed: ${response.status} ${response.statusText}`
        );
      }

      const roles: KeycloakRole[] = await response.data;

      this.metrics?.recordCounter("keycloak.user_manager.get_realm_roles", 1);
      this.metrics?.recordTimer(
        "keycloak.user_manager.get_realm_roles_duration",
        performance.now() - startTime
      );

      return roles;
    } catch (error) {
      this.logger.error("Get user realm roles failed", { error, userId });
      this.metrics?.recordCounter(
        "keycloak.user_manager.get_realm_roles_error",
        1
      );
      throw error;
    }
  }

  /**
   * Assign realm roles to user
   */
  async assignRealmRoles(userId: string, roleNames: string[]): Promise<void> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      // Get available realm roles
      const rolesResponse = await this.httpClient.get<KeycloakRole[]>(
        `${baseUrl}/roles`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(rolesResponse.status)) {
        throw new Error(
          `Get realm roles failed: ${rolesResponse.status} ${rolesResponse.statusText}`
        );
      }

      const allRoles: KeycloakRole[] = rolesResponse.data || [];
      const rolesToAssign = allRoles.filter((role) =>
        roleNames.includes(role.name)
      );

      if (rolesToAssign.length === 0) {
        this.logger.warn("No matching roles found", { roleNames });
        return;
      }

      // Assign roles
      const response = await this.httpClient.post(
        `${baseUrl}/users/${userId}/role-mappings/realm`,
        JSON.stringify(rolesToAssign),
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `Assign realm roles failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      this.metrics?.recordCounter(
        "keycloak.user_manager.assign_realm_roles",
        1
      );
      this.metrics?.recordTimer(
        "keycloak.user_manager.assign_realm_roles_duration",
        performance.now() - startTime
      );

      this.logger.info("Realm roles assigned", {
        userId,
        roles: rolesToAssign.map((r) => r.name),
      });
    } catch (error) {
      this.logger.error("Assign realm roles failed", {
        error,
        userId,
        roleNames,
      });
      this.metrics?.recordCounter(
        "keycloak.user_manager.assign_realm_roles_error",
        1
      );
      throw error;
    }
  }

  /**
   * Remove realm roles from user
   */
  async removeRealmRoles(userId: string, roleNames: string[]): Promise<void> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      // Get user's current realm roles
      const userRoles = await this.getUserRealmRoles(userId);
      const rolesToRemove = userRoles.filter((role) =>
        roleNames.includes(role.name)
      );

      if (rolesToRemove.length === 0) {
        this.logger.warn("No matching roles found to remove", { roleNames });
        return;
      }

      // Remove roles
      const response = await this.httpClient.delete(
        `${baseUrl}/users/${userId}/role-mappings/realm`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          data: rolesToRemove,
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `Remove realm roles failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      this.metrics?.recordCounter(
        "keycloak.user_manager.remove_realm_roles",
        1
      );
      this.metrics?.recordTimer(
        "keycloak.user_manager.remove_realm_roles_duration",
        performance.now() - startTime
      );

      this.logger.info("Realm roles removed", {
        userId,
        roles: rolesToRemove.map((r) => r.name),
      });
    } catch (error) {
      this.logger.error("Remove realm roles failed", {
        error,
        userId,
        roleNames,
      });
      this.metrics?.recordCounter(
        "keycloak.user_manager.remove_realm_roles_error",
        1
      );
      throw error;
    }
  }

  /**
   * Assign client roles to user
   */
  async assignClientRoles(
    userId: string,
    clientId: string,
    roleNames: string[]
  ): Promise<void> {
    const startTime = performance.now();

    try {
      const token = await this.ensureAdminToken();
      const baseUrl = this.getAdminApiUrl();

      // Get client internal ID
      const clientsResponse = await this.httpClient.get<KeycloakUser[]>(
        `${baseUrl}/clients?clientId=${clientId}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(clientsResponse.status)) {
        throw new Error(
          `Get client failed: ${clientsResponse.status} ${clientsResponse.statusText}`
        );
      }

      const clients = (await clientsResponse.data) as any[];
      if (!Array.isArray(clients) || clients.length === 0) {
        throw new Error(`Client not found: ${clientId}`);
      }

      const internalClientId = clients[0].id;

      // Get available client roles
      const rolesResponse = await this.httpClient.get<KeycloakRole[]>(
        `${baseUrl}/clients/${internalClientId}/roles`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(rolesResponse.status)) {
        throw new Error(
          `Get client roles failed: ${rolesResponse.status} ${rolesResponse.statusText}`
        );
      }

      const allRoles: KeycloakRole[] = await rolesResponse.data;
      const rolesToAssign = allRoles.filter((role) =>
        roleNames.includes(role.name)
      );

      if (rolesToAssign.length === 0) {
        this.logger.warn("No matching client roles found", {
          clientId,
          roleNames,
        });
        return;
      }

      // Assign client roles
      const response = await this.httpClient.post(
        `${baseUrl}/users/${userId}/role-mappings/clients/${internalClientId}`,
        JSON.stringify(rolesToAssign),
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!HttpStatus.isSuccess(response.status)) {
        const errorText = await response.data;
        throw new Error(
          `Assign client roles failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }

      this.metrics?.recordCounter(
        "keycloak.user_manager.assign_client_roles",
        1
      );
      this.metrics?.recordTimer(
        "keycloak.user_manager.assign_client_roles_duration",
        performance.now() - startTime
      );

      this.logger.info("Client roles assigned", {
        userId,
        clientId,
        roles: rolesToAssign.map((r) => r.name),
      });
    } catch (error) {
      this.logger.error("Assign client roles failed", {
        error,
        userId,
        clientId,
        roleNames,
      });
      this.metrics?.recordCounter(
        "keycloak.user_manager.assign_client_roles_error",
        1
      );
      throw error;
    }
  }

  /**
   * Convert Keycloak user to UserInfo
   */
  convertToUserInfo(
    keycloakUser: KeycloakUser,
    roles: string[] = [],
    permissions: string[] = []
  ): UserInfo {
    return {
      id: keycloakUser.id!,
      username: keycloakUser.username,
      email: keycloakUser.email,
      name:
        [keycloakUser.firstName, keycloakUser.lastName]
          .filter(Boolean)
          .join(" ") || undefined,
      roles,
      permissions,
      metadata: {
        enabled: keycloakUser.enabled,
        emailVerified: keycloakUser.emailVerified,
        createdTimestamp: keycloakUser.createdTimestamp,
        attributes: keycloakUser.attributes,
      },
    };
  }

  /**
   * Get comprehensive user info with roles
   */
  async getCompleteUserInfo(userId: string): Promise<UserInfo | null> {
    try {
      const user = await this.getUserById(userId);
      if (!user) {
        return null;
      }

      const realmRoles = await this.getUserRealmRoles(userId);
      const roles = realmRoles.map((role) => `realm:${role.name}`);

      // Additional client roles could be fetched here if needed
      const permissions: string[] = []; // Would need additional API calls for permissions

      return this.convertToUserInfo(user, roles, permissions);
    } catch (error) {
      this.logger.error("Get complete user info failed", { error, userId });
      throw error;
    }
  }
}
