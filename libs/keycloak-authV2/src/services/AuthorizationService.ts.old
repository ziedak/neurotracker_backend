/**
 * Authorization Service
 *
 * Main service for handling authorization decisions using CASL abilities.
 * Provides high-level interface for permission checking and role management.
 */

import crypto from "crypto";
import { z } from "zod";
import type {
  Action,
  Subjects,
  AuthorizationContext,
  ResourceContext,
  AuthorizationResult,
  Role,
  AppAbility,
} from "../types/authorization.types";
import { AbilityFactory } from "./ability";
import type { IMetricsCollector } from "@libs/monitoring";

import type { CacheService } from "@libs/database";
import { createLogger } from "@libs/utils";

/**
 * Zod schemas for input validation
 */
const authorizationContextSchema = z.object({
  userId: z
    .string()
    .min(1, "userId cannot be empty")
    .max(100, "userId too long (max 100 characters)")
    .regex(/^[a-zA-Z0-9._@-]+$/, "userId contains invalid characters"),
  roles: z
    .array(
      z
        .string()
        .min(1, "Role cannot be empty")
        .max(50, "Role name too long (max 50 characters)")
        .regex(/^[a-zA-Z0-9._-]+$/, "Role contains invalid characters")
    )
    .max(50, "Too many roles (max 50)"),
  sessionId: z.string().max(200, "Invalid sessionId format").optional(),
  ipAddress: z.string().max(45, "Invalid ipAddress format").optional(),
  userAgent: z.string().max(500, "Invalid userAgent format").optional(),
});

const actionSchema = z
  .string()
  .min(1, "Invalid action: must be a non-empty string");

const subjectSchema = z
  .string()
  .min(1, "Invalid subject: must be a non-empty string");

const resourceContextSchema = z
  .object({
    type: z.string().optional(),
    id: z.string().optional(),
    ownerId: z.string().optional(),
    organizationId: z.string().optional(),
    metadata: z.record(z.any()).optional(),
  })
  .optional();

const permissionCheckSchema = z.object({
  action: actionSchema,
  subject: subjectSchema,
  resource: resourceContextSchema.optional(),
});

const permissionChecksSchema = z
  .array(permissionCheckSchema)
  .min(1, "No permission checks specified - access denied by default");

/**
 * Configuration for the Authorization Service
 */
export interface AuthorizationServiceConfig {
  enableAuditLog?: boolean;
  enableMetrics?: boolean;
  cachePermissionResults?: boolean;
  permissionCacheTtl?: number;
  strictMode?: boolean;
}

/**
 * Authorization Service implementation
 */
export class AuthorizationService {
  private readonly config: Required<AuthorizationServiceConfig>;
  private readonly abilityFactory: AbilityFactory;
  private readonly permissionCache = new WeakMap<AppAbility, string[]>();
  private readonly pendingCacheOperations = new Map<
    string,
    {
      promise: Promise<AuthorizationResult>;
      timestamp: number;
      timeout: NodeJS.Timeout;
    }
  >();
  private cleanupInterval?: NodeJS.Timeout | undefined;

  constructor(
    private readonly logger = createLogger("AuthorizationService"),
    private readonly metrics?: IMetricsCollector,
    private readonly cacheService?: CacheService,
    config: AuthorizationServiceConfig = {}
  ) {
    // SECURITY: Validate configuration parameters with bounds checking
    this.validateConfiguration(config);

    this.config = {
      enableAuditLog: config.enableAuditLog ?? true,
      enableMetrics: config.enableMetrics ?? true,
      cachePermissionResults: config.cachePermissionResults ?? true,
      permissionCacheTtl: Math.min(
        Math.max(config.permissionCacheTtl ?? 300, 60),
        3600
      ), // 1min - 1hour
      strictMode: config.strictMode ?? true,
    };

    this.abilityFactory = new AbilityFactory(metrics, this.cacheService, {
      enableCaching: true,
      cacheTimeout: Math.min(this.config.permissionCacheTtl * 1000, 3600000), // Max 1 hour
      strictMode: this.config.strictMode,
      auditEnabled: this.config.enableAuditLog,
    });

    // Start cleanup interval for pending operations
    this.startCleanupInterval();
  }

  /**
   * Start periodic cleanup of stale pending operations
   */
  private startCleanupInterval(): void {
    this.cleanupInterval = setInterval(() => {
      this.cleanupStalePendingOperations();
    }, 5 * 60 * 1000); // 5 minutes
  }

  /**
   * Clean up stale pending operations to prevent memory leaks
   */
  private cleanupStalePendingOperations(): void {
    const now = Date.now();
    const staleThreshold = 60 * 1000; // 1 minute

    for (const [key, operation] of this.pendingCacheOperations) {
      if (now - operation.timestamp > staleThreshold) {
        clearTimeout(operation.timeout);
        this.pendingCacheOperations.delete(key);
        this.logger?.warn("Cleaned up stale pending authorization operation", {
          cacheKey: key.substring(0, 20) + "...",
          age: now - operation.timestamp,
        });
      }
    }
  }

  /**
   * Validate configuration parameters with bounds checking
   */
  private validateConfiguration(config: AuthorizationServiceConfig): void {
    if (config.permissionCacheTtl !== undefined) {
      if (
        typeof config.permissionCacheTtl !== "number" ||
        isNaN(config.permissionCacheTtl) ||
        config.permissionCacheTtl < 0
      ) {
        throw new Error("permissionCacheTtl must be a non-negative number");
      }
      if (config.permissionCacheTtl > 86400) {
        // 24 hours max
        throw new Error(
          "permissionCacheTtl cannot exceed 86400 seconds (24 hours)"
        );
      }
    }

    // Validate boolean configurations
    const booleanFields: (keyof AuthorizationServiceConfig)[] = [
      "enableAuditLog",
      "enableMetrics",
      "cachePermissionResults",
      "strictMode",
    ];

    for (const field of booleanFields) {
      if (config[field] !== undefined && typeof config[field] !== "boolean") {
        throw new Error(`${field} must be a boolean value`);
      }
    }
  }

  /**
   * Comprehensive input validation for authorization context using Zod
   */
  private validateAuthorizationContext(context: AuthorizationContext): {
    valid: boolean;
    reason?: string;
  } {
    const result = authorizationContextSchema.safeParse(context);
    if (!result.success) {
      // Extract the first error message for user-friendly feedback
      const firstError = result.error.issues[0];
      return {
        valid: false,
        reason: firstError?.message || "Invalid authorization context",
      };
    }
    return { valid: true };
  }

  /**
   * Check if user can perform an action on a subject
   */
  async can(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource?: ResourceContext
  ): Promise<AuthorizationResult> {
    // ENHANCED INPUT VALIDATION
    const contextValidation = this.validateAuthorizationContext(context);
    if (!contextValidation.valid) {
      return {
        granted: false,
        reason: `Invalid authorization context: ${contextValidation.reason}`,
        context: {
          action,
          subject,
          userId: context?.userId || "unknown",
          timestamp: new Date(),
        },
      };
    }

    // Validate action and subject using Zod
    const actionValidation = actionSchema.safeParse(action);
    if (!actionValidation.success) {
      return {
        granted: false,
        reason: "Invalid action format", // Sanitized error message
        context: {
          action: (action || "unknown") as Action,
          subject,
          userId: context.userId,
          timestamp: new Date(),
        },
      };
    }

    const subjectValidation = subjectSchema.safeParse(subject);
    if (!subjectValidation.success) {
      return {
        granted: false,
        reason: "Invalid subject format", // Sanitized error message
        context: {
          action,
          subject: (subject || "unknown") as Subjects,
          userId: context.userId,
          timestamp: new Date(),
        },
      };
    }

    // Validate resource context if provided
    if (resource !== undefined) {
      const resourceValidation = resourceContextSchema.safeParse(resource);
      if (!resourceValidation.success) {
        return {
          granted: false,
          reason: "Invalid resource context format", // Sanitized error message
          context: {
            action,
            subject,
            userId: context.userId,
            timestamp: new Date(),
          },
        };
      }
    }

    const startTime = Date.now();

    try {
      // Check cache first with atomic operation to prevent race conditions
      if (this.config.cachePermissionResults && this.cacheService) {
        const cacheKey = this.generateCacheKey(
          context,
          action,
          subject,
          resource
        );

        // Check if there's already a pending operation for this key
        const pendingOperation = this.pendingCacheOperations.get(cacheKey);
        if (pendingOperation) {
          // Wait for the pending operation instead of computing again
          try {
            this.recordMetrics(
              "cache_pending",
              context,
              action,
              subject,
              Date.now() - startTime
            );
            return await pendingOperation.promise;
          } catch (pendingError) {
            // If pending operation fails, continue with fresh computation
            clearTimeout(pendingOperation.timeout);
            this.pendingCacheOperations.delete(cacheKey);
          }
        }

        // Try to get from cache atomically
        const cachedResult = await this.getCachedResult(
          context,
          action,
          subject,
          resource
        );
        if (cachedResult) {
          try {
            this.recordMetrics(
              "cache_hit",
              context,
              action,
              subject,
              Date.now() - startTime
            );
          } catch (metricsError) {
            this.logger?.warn("Failed to record cache hit metrics", {
              metricsError,
            });
          }
          return cachedResult;
        }

        // Create a promise for this computation to prevent race conditions
        const computationPromise = this.computeAuthorizationResult(
          context,
          action,
          subject,
          resource
        );

        // Create timeout to prevent hanging operations
        const timeout = setTimeout(() => {
          this.pendingCacheOperations.delete(cacheKey);
          this.logger?.warn("Authorization computation timeout", {
            cacheKey: cacheKey.substring(0, 20) + "...",
          });
        }, 60 * 1000); // 1 minute timeout

        const operation = {
          promise: computationPromise,
          timestamp: Date.now(),
          timeout,
        };

        this.pendingCacheOperations.set(cacheKey, operation);

        try {
          const result = await computationPromise;

          // Cache the result atomically
          await this.cacheResult(context, action, subject, resource, result);

          return result;
        } finally {
          // Always clean up the pending operation
          const operation = this.pendingCacheOperations.get(cacheKey);
          if (operation) {
            clearTimeout(operation.timeout);
            this.pendingCacheOperations.delete(cacheKey);
          }
        }
      }

      // No caching - compute directly
      return await this.computeAuthorizationResult(
        context,
        action,
        subject,
        resource
      );
    } catch (error) {
      const errorResult: AuthorizationResult = {
        granted: false,
        reason: "Authorization check failed due to system error", // SECURITY: Sanitized error message
        context: {
          action,
          subject,
          userId: context.userId,
          timestamp: new Date(),
        },
      };

      this.logger?.error("Authorization check failed", {
        error,
        userId: context.userId,
        action,
        subject,
        resource,
      });

      // Add error boundary for error metrics
      try {
        this.recordMetrics(
          "authorization_error",
          context,
          action,
          subject,
          Date.now() - startTime
        );
      } catch (metricsError) {
        this.logger?.warn("Failed to record error metrics", { metricsError });
      }

      return errorResult;
    }
  }

  /**
   * Compute authorization result with audit logging and metrics
   */
  private async computeAuthorizationResult(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource?: ResourceContext
  ): Promise<AuthorizationResult> {
    const startTime = Date.now();

    // Create ability for user
    const ability = await this.abilityFactory.createAbilityForUser(context);

    // Perform authorization check
    const result = this._checkPermissionWithAbility(
      ability,
      action,
      subject,
      resource,
      context
    );

    // Log and record metrics with error boundaries
    try {
      await this.auditAuthorizationDecision(
        context,
        action,
        subject,
        resource,
        result
      );
    } catch (auditError) {
      // Audit failures should not break authorization
      this.logger?.warn("Failed to audit authorization decision", {
        auditError,
        userId: context.userId,
        action,
        subject,
      });
    }

    // Add error boundary for metrics recording
    try {
      this.recordMetrics(
        "authorization_check",
        context,
        action,
        subject,
        Date.now() - startTime
      );
    } catch (metricsError) {
      // Metrics failures should not break authorization
      this.logger?.warn("Failed to record authorization metrics", {
        metricsError,
        userId: context.userId,
        action,
        subject,
      });
    }

    return result;
  }

  /**
   * Check if user cannot perform an action (explicit denial)
   */
  async cannot(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource?: ResourceContext
  ): Promise<AuthorizationResult> {
    const result = await this.can(context, action, subject, resource);
    return {
      ...result,
      granted: !result.granted,
      reason: result.granted
        ? `Access denied: Action ${action} on ${subject} is not permitted`
        : result.reason ||
          `Access denied: Action ${action} on ${subject} is not permitted`,
    };
  }

  /**
   * Check multiple permissions at once
   */
  async canAll(
    context: AuthorizationContext,
    checks: Array<{
      action: Action;
      subject: Subjects;
      resource?: ResourceContext;
    }>
  ): Promise<AuthorizationResult> {
    // ENHANCED INPUT VALIDATION using same validation as can()
    const contextValidation = this.validateAuthorizationContext(context);
    if (!contextValidation.valid) {
      return {
        granted: false,
        reason: `Invalid authorization context: ${contextValidation.reason}`,
        context: {
          action: "multiple" as Action,
          subject: "multiple" as Subjects,
          userId: context?.userId || "unknown",
          timestamp: new Date(),
        },
      };
    }

    // Validate permission checks using Zod
    const checksValidation = permissionChecksSchema.safeParse(checks);
    if (!checksValidation.success) {
      return {
        granted: false,
        reason:
          checksValidation.error.issues[0]?.message ||
          "Invalid permission checks",
        context: {
          action: "multiple" as Action,
          subject: "multiple" as Subjects,
          userId: context.userId,
          timestamp: new Date(),
        },
      };
    }

    const results = await Promise.all(
      checks.map((check) =>
        this.can(context, check.action, check.subject, check.resource)
      )
    );

    const allGranted = results.every((result) => result.granted);
    const deniedChecks = results.filter((result) => !result.granted);

    return {
      granted: allGranted,
      reason: allGranted
        ? "All permissions granted"
        : `Access denied: ${deniedChecks.length} of ${results.length} checks failed`,
      missingPermissions: deniedChecks.flatMap(
        (result) =>
          result.requiredPermissions || [
            `${result.context?.action}_${result.context?.subject}`,
          ]
      ),
      context: {
        action: "multiple" as Action,
        subject: "multiple" as Subjects,
        userId: context.userId,
        timestamp: new Date(),
      },
    };
  }

  /**
   * Check if user has any of the specified roles
   */
  hasAnyRole(context: AuthorizationContext, roles: Role[]): boolean {
    if (
      !context ||
      !Array.isArray(context.roles) ||
      !Array.isArray(roles) ||
      roles.length === 0
    ) {
      return false;
    }
    return roles.some((role) => context.roles.includes(role));
  }

  /**
   * Check if user has all specified roles
   */
  hasAllRoles(context: AuthorizationContext, roles: Role[]): boolean {
    if (!context || !Array.isArray(context.roles)) {
      return false;
    }

    // LOGIC FIX: Empty role array should return true (vacuous truth)
    // "User has all roles in empty set" = true by mathematical definition
    if (!Array.isArray(roles) || roles.length === 0) {
      return true;
    }

    return roles.every((role) => context.roles.includes(role));
  }

  /**
   * Get user's effective permissions with WeakMap caching optimization
   */
  async getUserPermissions(context: AuthorizationContext): Promise<string[]> {
    try {
      // Input validation
      if (!context || !context.userId || !Array.isArray(context.roles)) {
        this.logger?.warn("Invalid context provided to getUserPermissions", {
          context,
        });
        return [];
      }

      const ability = await this.abilityFactory.createAbilityForUser(context);

      // Check WeakMap cache first for this ability instance
      const cachedPermissions = this.permissionCache.get(ability);
      if (cachedPermissions) {
        return cachedPermissions;
      }

      // Extract rules from ability and convert to readable permissions
      const rules = ability.rules;
      const permissionsSet = new Set<string>(); // Use Set for O(1) deduplication

      // OPTIMIZATION: Single loop with flat mapping instead of nested loops
      for (const rule of rules) {
        try {
          // Safely extract action and subject, handling various CASL rule formats
          const actions = Array.isArray(rule.action)
            ? rule.action
            : rule.action
            ? [rule.action]
            : [];

          const subjects = Array.isArray(rule.subject)
            ? rule.subject
            : rule.subject
            ? [rule.subject]
            : [];

          // Use flat mapping to avoid nested loops - O(n) instead of O(n²)
          const rulePermissions = actions.flatMap((action) =>
            subjects
              .filter(
                (subject) =>
                  action &&
                  subject &&
                  typeof action === "string" &&
                  typeof subject === "string"
              )
              .map((subject) => {
                const prefix = rule.inverted ? "!" : "";
                return `${prefix}${action}_${subject}`;
              })
          );

          // Add to Set for automatic deduplication
          rulePermissions.forEach((perm) => permissionsSet.add(perm));
        } catch (ruleError) {
          // Log rule processing errors but continue with other rules
          this.logger?.warn("Failed to process authorization rule", {
            rule,
            error:
              ruleError instanceof Error ? ruleError.message : "Unknown error",
          });
        }
      }

      // Convert Set back to array
      const permissions = Array.from(permissionsSet);

      // Cache in WeakMap for automatic garbage collection
      this.permissionCache.set(ability, permissions);

      return permissions;
    } catch (error) {
      // Enhanced error context for better debugging
      this.logger?.error("Failed to get user permissions", {
        userId: context?.userId,
        roles: context?.roles,
        contextType: typeof context,
        hasAbilityFactory: !!this.abilityFactory,
        error: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
      });
      return [];
    }
  }

  /**
   * Clear authorization cache for user - optimized single operation
   */
  async clearUserCache(userId: string): Promise<void> {
    if (!userId || typeof userId !== "string") {
      this.logger?.warn("Cannot clear cache: valid userId is required");
      return;
    }

    try {
      // Clear ability factory cache
      this.abilityFactory.clearCache(userId);

      // LIFECYCLE FIX: Clear WeakMap entries for this user's abilities
      // Note: WeakMap entries are automatically garbage collected when abilities are disposed
      // But we can help by clearing related user data

      // PERFORMANCE FIX: Optimized single cache clearing operation
      if (this.cacheService) {
        try {
          // Use a more targeted approach with single operation
          // Hash the userId to create a consistent pattern match
          const userHash = crypto
            .createHash("sha256")
            .update(userId)
            .digest("hex")
            .substring(0, 16);
          const pattern = `auth:*${userHash}*`;

          // Single optimized invalidation
          const invalidatedCount = await this.cacheService.invalidatePattern(
            pattern
          );

          this.logger?.info("Authorization cache cleared efficiently", {
            userId: userId.substring(0, 8) + "***", // Partially obscured for logs
            invalidatedKeys: invalidatedCount,
            pattern: "optimized_single_pattern",
          });
        } catch (cacheError) {
          // Fallback to direct key deletion if pattern matching fails
          this.logger?.warn("Pattern cache clearing failed, using fallback", {
            userId: userId.substring(0, 8) + "***",
            error:
              cacheError instanceof Error
                ? cacheError.message
                : "Unknown error",
          });

          // Don't implement complex fallback - let cache naturally expire
          // This prevents DoS from expensive operations
        }
      }

      this.logger?.info("Authorization cache clearing completed", {
        userId: userId.substring(0, 8) + "***",
      });
    } catch (error) {
      this.logger?.error("Failed to clear authorization cache", {
        userId: userId.substring(0, 8) + "***",
        error: error instanceof Error ? error.message : "Unknown error",
      });
      // Don't throw - cache clearing failures should not be fatal
    }
  }

  /**
   * Cleanup method for proper lifecycle management
   */
  async cleanup(): Promise<void> {
    try {
      // Clear cleanup interval
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = undefined;
      }

      // Clear all pending cache operations and their timeouts to prevent memory leaks
      for (const [, operation] of this.pendingCacheOperations) {
        clearTimeout(operation.timeout);
      }
      this.pendingCacheOperations.clear();

      // Cleanup ability factory
      if (
        this.abilityFactory &&
        typeof this.abilityFactory.cleanup === "function"
      ) {
        await this.abilityFactory.cleanup();
      }

      // The WeakMap (permissionCache) will automatically be garbage collected
      // when ability objects are no longer referenced

      this.logger?.info("AuthorizationService cleanup completed");
    } catch (error) {
      this.logger?.error("Failed to cleanup AuthorizationService", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  /**
   * Securely sanitize resource metadata to prevent prototype pollution
   */
  private sanitizeMetadata(obj: any, depth = 0): any {
    // Prevent deep recursion attacks
    if (depth > 10) return null;
    if (obj === null || obj === undefined) return null;
    if (typeof obj !== "object") return obj;
    if (Array.isArray(obj))
      return obj.map((item) => this.sanitizeMetadata(item, depth + 1));

    const clean: any = {};
    for (const [key, value] of Object.entries(obj)) {
      // CRITICAL: Block all prototype pollution vectors
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        continue;
      }
      // Prevent other dangerous keys
      if (key.startsWith("__") || key.includes("prototype")) {
        continue;
      }
      clean[key] = this.sanitizeMetadata(value, depth + 1);
    }
    return clean;
  }

  /**
   * Perform the actual authorization check with proper type safety
   */
  private _checkPermissionWithAbility(
    ability: AppAbility,
    action: Action,
    subject: Subjects,
    resource: ResourceContext | undefined,
    context: AuthorizationContext
  ): AuthorizationResult {
    // Create subject instance with resource data if available
    // SECURITY FIX: Use secure deep sanitization to prevent prototype pollution
    const subjectInstance = resource
      ? {
          // Only allow specific safe properties with proper sanitization
          type: typeof resource.type === "string" ? resource.type : undefined,
          id: typeof resource.id === "string" ? resource.id : undefined,
          ownerId:
            typeof resource.ownerId === "string" ? resource.ownerId : undefined,
          organizationId:
            typeof resource.organizationId === "string"
              ? resource.organizationId
              : undefined,
          metadata: resource.metadata
            ? this.sanitizeMetadata(resource.metadata)
            : undefined,
          __type: subject,
        }
      : subject;

    // TYPE SAFETY FIX: Properly handle different subject types for CASL
    let granted: boolean;
    try {
      if (typeof subjectInstance === "object" && subjectInstance !== null) {
        // For object subjects with resource data - cast to any for CASL compatibility
        granted = ability.can(action, subjectInstance as any);
      } else {
        // For string subjects - use the subject directly
        granted = ability.can(action, subject);
      }
    } catch (abilityError) {
      // Handle CASL errors gracefully
      this.logger?.warn("CASL ability check failed", {
        error:
          abilityError instanceof Error
            ? abilityError.message
            : "Unknown error",
        action,
        subject,
        userId: context.userId,
      });
      granted = false; // Fail secure
    }

    const result: AuthorizationResult = {
      granted,
      reason: granted
        ? `Access granted: User has ${action} permission on ${subject}`
        : `Access denied: User lacks ${action} permission on ${subject}`,
      requiredPermissions: [`${action}_${subject}`],
      context: {
        action,
        subject,
        userId: context.userId,
        timestamp: new Date(),
      },
    };

    if (!granted) {
      // Find missing permissions
      result.missingPermissions = [`${action}_${subject}`];
    }

    return result;
  }

  /**
   * Get cached authorization result
   */
  private async getCachedResult(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource?: ResourceContext
  ): Promise<AuthorizationResult | null> {
    if (!this.cacheService) return null;

    const cacheKey = this.generateCacheKey(context, action, subject, resource);

    try {
      const cacheResult = await this.cacheService.get<AuthorizationResult>(
        cacheKey
      );
      if (cacheResult.data) {
        return cacheResult.data;
      }
      return null;
    } catch (error) {
      this.logger?.warn("Failed to get cached authorization result", {
        error,
        cacheKey,
      });
      return null;
    }
  }

  /**
   * Cache authorization result
   */
  private async cacheResult(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource: ResourceContext | undefined,
    result: AuthorizationResult
  ): Promise<void> {
    if (!this.cacheService) return;

    const cacheKey = this.generateCacheKey(context, action, subject, resource);

    try {
      await this.cacheService.set(
        cacheKey,
        result,
        this.config.permissionCacheTtl
      );
    } catch (error) {
      this.logger?.warn("Failed to cache authorization result", {
        error,
        cacheKey,
      });
    }
  }

  /**
   * Generate secure cache key for authorization result
   * SECURITY FIX: Use full hash to prevent collisions and PII exposure
   */
  private generateCacheKey(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource?: ResourceContext
  ): string {
    try {
      // Create complete key data structure for hashing
      const keyData = {
        userId: context.userId,
        roles: Array.isArray(context.roles) ? [...context.roles].sort() : [],
        action,
        subject,
        resource: resource
          ? {
              type: resource.type || "",
              id: resource.id || "",
              ownerId: resource.ownerId || "",
              organizationId: resource.organizationId || "",
              // Include metadata hash to ensure uniqueness
              metadataHash: resource.metadata
                ? crypto
                    .createHash("sha256")
                    .update(JSON.stringify(resource.metadata))
                    .digest("hex")
                    .substring(0, 16)
                : "",
            }
          : null,
        // Add timestamp component for cache rotation
        timeWindow: Math.floor(
          Date.now() / (this.config.permissionCacheTtl * 1000)
        ),
      };

      // SECURITY FIX: Use full hash to prevent collisions
      const keyString = JSON.stringify(keyData);
      const hash = crypto.createHash("sha256").update(keyString).digest("hex");

      // Use full hash for maximum collision resistance
      return `auth:${hash}`;
    } catch (error) {
      // Fallback with secure error handling
      this.logger?.warn("Failed to generate cache key, using fallback", {
        error: error instanceof Error ? error.message : "Unknown error",
      });

      // Deterministic fallback that still prevents PII exposure
      const fallbackData = `${
        context.userId
      }-${action}-${subject}-${Date.now()}`;
      const hash = crypto
        .createHash("sha256")
        .update(fallbackData)
        .digest("hex");
      return `auth:fallback:${hash}`;
    }
  }

  /**
   * Audit authorization decision
   */
  private async auditAuthorizationDecision(
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    resource: ResourceContext | undefined,
    result: AuthorizationResult
  ): Promise<void> {
    if (!this.config.enableAuditLog) return;

    const auditEntry = {
      timestamp: new Date().toISOString(),
      userId: context.userId,
      action,
      subject,
      resource: resource ? { type: resource.type, id: resource.id } : null,
      granted: result.granted,
      reason: result.reason,
      userRoles: context.roles,
      sessionId: context.sessionId,
      ipAddress: context.ipAddress,
      userAgent: context.userAgent,
    };

    this.logger?.info("Authorization decision", auditEntry);
  }

  /**
   * Record authorization metrics
   */
  private recordMetrics(
    operation: string,
    context: AuthorizationContext,
    action: Action,
    subject: Subjects,
    duration: number
  ): void {
    if (!this.config.enableMetrics || !this.metrics) return;

    this.metrics.recordTimer(`authorization.${operation}.duration`, duration, {
      userId: context.userId,
      action,
      subject,
      rolesCount: (context.roles?.length || 0).toString(),
    });

    this.metrics.recordCounter(`authorization.${operation}.total`, 1, {
      action,
      subject,
    });
  }
}
