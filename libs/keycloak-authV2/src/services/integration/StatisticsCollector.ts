/**
 * Statistics Collector Component
 * Single Responsibility: Service statistics collection and caching with race condition protection
 */

import { createLogger } from "@libs/utils";
import type { IMetricsCollector } from "@libs/monitoring";
import type { IStatisticsCollector, IntegrationStats } from "./interfaces";
import type { KeycloakClient } from "../../client/KeycloakClient";
import type { KeycloakSessionManager } from "../session";

/**
 * Statistics Collector Component
 * Handles statistics collection with intelligent caching and race condition protection
 */
export class StatisticsCollector implements IStatisticsCollector {
  private readonly logger = createLogger("StatisticsCollector");

  // Performance optimization - cache with TTL and race condition protection
  private statsCache: {
    data: IntegrationStats;
    timestamp: number;
    ttl: number;
  } | null = null;

  private readonly STATS_CACHE_TTL = 5000; // 5 seconds
  private isGeneratingStats: boolean = false;

  constructor(
    private readonly keycloakClient: KeycloakClient,
    private readonly sessionManager: KeycloakSessionManager,
    private readonly metrics?: IMetricsCollector
  ) {}

  /**
   * Get service statistics with race condition protection
   */
  async getStats(): Promise<IntegrationStats> {
    const now = Date.now();

    // Check cache validity
    if (
      this.statsCache &&
      now - this.statsCache.timestamp < this.STATS_CACHE_TTL
    ) {
      return this.statsCache.data;
    }

    // If stats are being generated by another call, return stale cache if available
    if (this.isGeneratingStats) {
      if (this.statsCache) {
        return this.statsCache.data;
      }
      // If no cache available, proceed to generate (this is rare edge case)
    }

    // Set generation flag to prevent race conditions
    this.isGeneratingStats = true;

    try {
      // Generate fresh stats - reuse objects when possible
      const defaultClientStats = {
        discoveryLoaded: false,
        cacheEnabled: false,
        requestCount: 0,
      };

      const defaultTokenStats = {
        cacheHits: 0,
        cacheMisses: 0,
        validationCount: 0,
        jwksLoaded: false,
      };

      const stats: IntegrationStats = {
        session: await this.sessionManager.getSessionStats(),
        client: this.keycloakClient.getStats?.() || defaultClientStats,
        token: defaultTokenStats, // TokenManager doesn't expose stats currently
      };

      // Cache the result with atomic update
      this.statsCache = {
        data: stats,
        timestamp: now,
        ttl: this.STATS_CACHE_TTL,
      };

      // Record metrics
      this.metrics?.recordCounter("keycloak.integration.stats_generated", 1);

      return stats;
    } catch (error) {
      this.logger.error("Failed to generate statistics", {
        error: error instanceof Error ? error.message : String(error),
        errorType:
          error instanceof Error ? error.constructor.name : typeof error,
      });

      this.metrics?.recordCounter("keycloak.integration.stats_error", 1);

      // Return cached data if available, otherwise return default stats
      if (this.statsCache) {
        return this.statsCache.data;
      }

      // Return default stats structure if no cache available
      return {
        session: {
          activeSessions: 0,
          totalSessions: 0,
          sessionsCreated: 0,
          sessionsExpired: 0,
          averageSessionDuration: 0,
          peakConcurrentSessions: 0,
          successfulLogins: 0,
          failedLogins: 0,
          tokenRefreshCount: 0,
          securityViolations: 0,
        },
        client: {
          discoveryLoaded: false,
          cacheEnabled: false,
          requestCount: 0,
        },
        token: {
          cacheHits: 0,
          cacheMisses: 0,
          validationCount: 0,
          jwksLoaded: false,
        },
      };
    } finally {
      // Always clear the generation flag
      this.isGeneratingStats = false;
    }
  }

  /**
   * Clear statistics cache
   */
  clearCache(): void {
    this.statsCache = null;
    this.isGeneratingStats = false;
    this.logger.debug("Statistics cache cleared");
    this.metrics?.recordCounter("keycloak.integration.stats_cache_cleared", 1);
  }

  /**
   * Get resource usage statistics for monitoring memory leaks
   */
  getResourceStats(): {
    connections: {
      keycloak: boolean;
      database: boolean;
      sessions: number;
    };
    memory: {
      heapUsed: number;
      heapTotal: number;
    };
    uptime: number;
  } {
    const memUsage = process.memoryUsage();

    return {
      connections: {
        keycloak: !!this.keycloakClient,
        database: true, // Assume database connection exists
        sessions: 0, // Would need to implement session counting in session manager
      },
      memory: {
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
      },
      uptime: process.uptime(),
    };
  }

  /**
   * Get cache statistics for monitoring
   */
  getCacheStats(): {
    enabled: boolean;
    hitCount: number;
    missCount: number;
    size: number;
    lastGenerated?: Date;
    ttl: number;
  } {
    const result: {
      enabled: boolean;
      hitCount: number;
      missCount: number;
      size: number;
      lastGenerated?: Date;
      ttl: number;
    } = {
      enabled: true,
      hitCount: this.statsCache ? 1 : 0,
      missCount: this.statsCache ? 0 : 1,
      size: this.statsCache ? 1 : 0,
      ttl: this.STATS_CACHE_TTL,
    };

    if (this.statsCache) {
      result.lastGenerated = new Date(this.statsCache.timestamp);
    }

    return result;
  }
}
