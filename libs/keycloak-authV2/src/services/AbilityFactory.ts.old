/**
 * CASL Ability Factory Service
 *
 * Creates and manages user abilities using CASL for role-based
 * and attribute-based access control.
 */

import { AbilityBuilder, createMongoAbility } from "@casl/ability";
// Note: createMongoAbility uses MongoDB-style query syntax (like $or, $in)
// for in-memory object matching. It has NO dependency on MongoDB database.
// It works perfectly with PostgreSQL, Redis, or any other database.
import type {
  AppAbility,
  AuthorizationContext,
  AbilityFactoryConfig,
  Role,
  Permission,
} from "../types/authorization.types";

export type { AbilityFactoryConfig };
import {
  ROLE_DEFINITIONS,
  getEffectivePermissions,
} from "../config/roles.config";
import type { IMetricsCollector } from "@libs/monitoring";
import type { CacheService } from "@libs/database";
import { createLogger } from "@libs/utils";
import { createHash } from "crypto";

/**
 * Configuration constants to replace magic numbers
 */
interface AbilityFactoryConstants {
  readonly CLEANUP_INTERVAL_MS: number;
  readonly STALE_COMPUTATION_THRESHOLD_MS: number;
  readonly MAX_PENDING_COMPUTATIONS: number;
  readonly MAX_TEMPLATE_DEPTH: number;
  readonly CACHE_ROTATION_INTERVAL_MS: number;
  readonly MIN_CACHE_TIMEOUT_MS: number;
  readonly MAX_CACHE_TIMEOUT_MS: number;
}

const DEFAULT_CONSTANTS: AbilityFactoryConstants = {
  CLEANUP_INTERVAL_MS: 5 * 60 * 1000,
  STALE_COMPUTATION_THRESHOLD_MS: 30_000,
  MAX_PENDING_COMPUTATIONS: 100,
  MAX_TEMPLATE_DEPTH: 5,
  CACHE_ROTATION_INTERVAL_MS: 5 * 60 * 1000,
  MIN_CACHE_TIMEOUT_MS: 60_000,
  MAX_CACHE_TIMEOUT_MS: 3_600_000,
};

/**
 * Error hierarchy for better error handling
 */
export class AbilityFactoryError extends Error {
  constructor(message: string, public override cause?: Error) {
    super(message);
    this.name = "AbilityFactoryError";
  }
}

export class AbilityCacheError extends AbilityFactoryError {
  constructor(message: string, cause?: Error) {
    super(message, cause);
    this.name = "AbilityCacheError";
  }
}

export class AbilityValidationError extends AbilityFactoryError {
  constructor(message: string, cause?: Error) {
    super(message, cause);
    this.name = "AbilityValidationError";
  }
}

/**
 * Cached ability data structure
 */
interface CachedAbility {
  rules: any[];
  timestamp: number;
  userId: string;
  roles: Role[];
}

/**
 * Pending computation tracking structure
 */
interface PendingComputation {
  promise: Promise<AppAbility>;
  timestamp: number;
  timeout: NodeJS.Timeout;
}

/**
 * Factory service for creating user abilities with enterprise-grade caching
 */
export class AbilityFactory {
  private readonly config: Required<AbilityFactoryConfig>;
  private readonly constants: AbilityFactoryConstants;
  private readonly logger = createLogger("AbilityFactory");
  private readonly pendingComputations = new Map<string, PendingComputation>();
  private cleanupInterval?: NodeJS.Timeout | undefined;

  constructor(
    private readonly metrics?: IMetricsCollector,
    private readonly cacheService?: CacheService,
    config: AbilityFactoryConfig = {},
    constants: AbilityFactoryConstants = DEFAULT_CONSTANTS
  ) {
    this.constants = constants;

    // Validate and normalize configuration with bounds checking
    this.config = {
      enableCaching: config.enableCaching ?? true,
      cacheTimeout: Math.min(
        Math.max(
          config.cacheTimeout ?? 300_000,
          this.constants.MIN_CACHE_TIMEOUT_MS
        ),
        this.constants.MAX_CACHE_TIMEOUT_MS
      ),
      defaultRole: config.defaultRole ?? "guest",
      strictMode: config.strictMode ?? true,
      auditEnabled: config.auditEnabled ?? true,
    };

    this.logger.debug("AbilityFactory initialized", {
      enableCaching: this.config.enableCaching,
      cacheTimeout: this.config.cacheTimeout,
      hasCacheService: !!this.cacheService,
    });

    // Start periodic cleanup of pending operations to prevent memory leaks
    if (this.config.enableCaching) {
      this.startPeriodicCleanup();
    }
  }

  /**
   * Start periodic cleanup of stale pending operations
   */
  private startPeriodicCleanup(): void {
    // Clean up every 5 minutes using configurable interval
    this.cleanupInterval = setInterval(() => {
      this.cleanupStalePendingOperations();
    }, this.constants.CLEANUP_INTERVAL_MS);
  }

  /**
   * Clean up stale pending operations to prevent memory leaks
   */
  private cleanupStalePendingOperations(): void {
    const now = Date.now();

    for (const [key, computation] of this.pendingComputations) {
      const age = now - computation.timestamp;
      if (age > this.constants.STALE_COMPUTATION_THRESHOLD_MS) {
        clearTimeout(computation.timeout);
        this.pendingComputations.delete(key);
        this.logger.warn("Cleaned up stale pending computation", {
          key: key.substring(0, 20) + "...",
          age,
        });
      }
    }

    if (
      this.pendingComputations.size > this.constants.MAX_PENDING_COMPUTATIONS
    ) {
      this.logger.warn("High number of pending computations", {
        count: this.pendingComputations.size,
      });
    }
  }

  /**
   * Track computation with proper cleanup and timeout handling
   */
  private trackComputation(
    key: string,
    promise: Promise<AppAbility>
  ): Promise<AppAbility> {
    const timeout = setTimeout(() => {
      this.pendingComputations.delete(key);
      this.logger.warn("Computation timeout", {
        key: key.substring(0, 20) + "...",
      });
    }, this.constants.STALE_COMPUTATION_THRESHOLD_MS);

    const computation: PendingComputation = {
      promise,
      timestamp: Date.now(),
      timeout,
    };

    this.pendingComputations.set(key, computation);

    return promise.finally(() => {
      clearTimeout(timeout);
      this.pendingComputations.delete(key);
    });
  }

  /**
   * Create ability for a user context with enterprise-grade caching
   */
  async createAbilityForUser(
    context: AuthorizationContext
  ): Promise<AppAbility> {
    // Input validation
    if (!context?.userId || !Array.isArray(context.roles)) {
      this.logger.warn("Invalid context provided to createAbilityForUser", {
        hasUserId: !!context?.userId,
        hasRoles: Array.isArray(context?.roles),
      });
      return this.createRestrictiveAbility();
    }

    const cacheKey = this.getCacheKey(context);

    // Check cache first with race condition prevention
    if (this.config.enableCaching && this.cacheService) {
      // Check for pending computation to prevent duplicate work
      const pendingComputation = this.pendingComputations.get(cacheKey);
      if (pendingComputation) {
        this.metrics?.recordCounter("authorization.ability.pending_hit", 1, {
          userId: context.userId,
        });
        return pendingComputation.promise;
      }

      // Try cache first
      try {
        const cachedResult = await this.getCachedAbility(cacheKey);
        if (cachedResult) {
          this.metrics?.recordCounter("authorization.ability.cache_hit", 1, {
            userId: context.userId,
          });
          return cachedResult;
        }
      } catch (cacheError) {
        this.logger.warn("Cache retrieval failed, computing fresh ability", {
          error:
            cacheError instanceof Error ? cacheError.message : "Unknown error",
          userId: context.userId,
        });
      }
    }

    // Create computation promise and track it to prevent race conditions
    const computationPromise = this.computeAbility(context);

    if (this.config.enableCaching) {
      // Use the new tracking system
      return this.trackComputation(cacheKey, computationPromise);
    }

    return computationPromise;
  }

  /**
   * Compute and cache ability
   */
  private async computeAbility(
    context: AuthorizationContext
  ): Promise<AppAbility> {
    const startTime = Date.now();

    try {
      // Build ability
      const ability = this.buildAbility(context);

      // Cache the result if enabled
      if (this.config.enableCaching && this.cacheService) {
        await this.cacheAbility(context, ability);
      }

      this.metrics?.recordCounter("authorization.ability.created", 1, {
        userId: context.userId,
        rolesCount: context.roles.length.toString(),
      });

      this.metrics?.recordTimer(
        "authorization.ability.computation_time",
        Date.now() - startTime,
        { userId: context.userId }
      );

      return ability;
    } catch (error) {
      this.metrics?.recordCounter("authorization.ability.build_error", 1, {
        userId: context.userId,
        error: error instanceof Error ? error.message : "Unknown error",
      });

      this.logger.error("Failed to compute ability", {
        error: error instanceof Error ? error.message : "Unknown error",
        userId: context.userId,
        roles: context.roles,
      });

      // Return restrictive ability on error
      return this.createRestrictiveAbility();
    }
  }

  /**
   * Get cached ability with proper deserialization and validation
   */
  private async getCachedAbility(cacheKey: string): Promise<AppAbility | null> {
    try {
      const result = await this.cacheService!.get<CachedAbility>(cacheKey);

      if (
        result.data &&
        this.isValidCachedAbility(result.data) &&
        this.isCacheValid(result.data.timestamp)
      ) {
        return this.deserializeAbility(result.data.rules);
      }

      return null;
    } catch (error) {
      // Escalate cache errors instead of hiding them
      throw new AbilityCacheError(
        "Failed to retrieve cached ability",
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }

  /**
   * Validate cached ability structure
   */
  private isValidCachedAbility(data: any): data is CachedAbility {
    if (!data || typeof data !== "object") {
      return false;
    }

    return (
      typeof data.timestamp === "number" &&
      typeof data.userId === "string" &&
      Array.isArray(data.roles) &&
      Array.isArray(data.rules) &&
      data.timestamp > 0 &&
      data.userId.length > 0 &&
      data.roles.every((role: any) => typeof role === "string")
    );
  }

  /**
   * Cache ability with proper serialization
   */
  private async cacheAbility(
    context: AuthorizationContext,
    ability: AppAbility
  ): Promise<void> {
    try {
      const cacheKey = this.getCacheKey(context);
      const cachedData: CachedAbility = {
        rules: ability.rules,
        timestamp: Date.now(),
        userId: context.userId,
        roles: context.roles,
      };

      const ttlSeconds = Math.floor(this.config.cacheTimeout / 1000);
      await this.cacheService!.set(cacheKey, cachedData, ttlSeconds);

      this.metrics?.recordCounter("authorization.ability.cache_set", 1, {
        userId: context.userId,
      });
    } catch (error) {
      this.logger.warn("Failed to cache ability", {
        error: error instanceof Error ? error.message : "Unknown error",
        userId: context.userId,
      });
    }
  }

  /**
   * Serialize ability to storable format with validation
   */
  serializeAbility(ability: AppAbility): string {
    try {
      if (!ability || !ability.rules) {
        throw new AbilityValidationError(
          "Invalid ability provided for serialization"
        );
      }
      return JSON.stringify(ability.rules);
    } catch (error) {
      this.logger.error("Failed to serialize ability", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
      return "[]";
    }
  }

  /**
   * Deserialize ability from stored format with validation
   */
  deserializeAbility(rulesJson: string | any[]): AppAbility {
    try {
      let rules: any[];

      if (Array.isArray(rulesJson)) {
        rules = rulesJson;
      } else if (typeof rulesJson === "string") {
        rules = JSON.parse(rulesJson);
        if (!Array.isArray(rules)) {
          throw new AbilityValidationError(
            "Deserialized rules must be an array"
          );
        }
      } else {
        throw new AbilityValidationError("Rules must be string or array");
      }

      return createMongoAbility(rules) as AppAbility;
    } catch (error) {
      this.logger.error("Failed to deserialize ability", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
      return this.createRestrictiveAbility();
    }
  }

  /**
   * Create a restrictive ability for error cases
   */
  private createRestrictiveAbility(): AppAbility {
    const { build } = new AbilityBuilder<AppAbility>(createMongoAbility);
    return build() as AppAbility;
  }

  /**
   * Build ability from user context
   */
  private buildAbility(context: AuthorizationContext): AppAbility {
    const { can, cannot, build } = new AbilityBuilder<AppAbility>(
      createMongoAbility
    );

    try {
      // Get all effective permissions for user roles
      const permissions = this.getEffectivePermissionsForRoles(context.roles);

      // Apply permissions to ability builder
      for (const permission of permissions) {
        const conditions = this.resolveConditions(
          permission.conditions,
          context
        );

        if (permission.inverted) {
          cannot(permission.action, permission.subject, conditions);
        } else {
          if (permission.fields) {
            can(
              permission.action,
              permission.subject,
              permission.fields,
              conditions
            );
          } else {
            can(permission.action, permission.subject, conditions);
          }
        }
      }

      // Apply additional context-based permissions
      this.applyContextualPermissions(can, context);

      return build() as AppAbility;
    } catch (error) {
      this.metrics?.recordCounter("authorization.ability.build_error", 1, {
        userId: context.userId,
        error: error instanceof Error ? error.message : "Unknown error",
      });

      // Return restrictive ability on error
      return build() as AppAbility;
    }
  }

  /**
   * Get effective permissions for multiple roles
   */
  private getEffectivePermissionsForRoles(roles: Role[]): Permission[] {
    const allPermissions: Permission[] = [];

    for (const role of roles) {
      if (ROLE_DEFINITIONS[role]) {
        allPermissions.push(...getEffectivePermissions(role));
      }
    }

    // Remove duplicates and resolve conflicts
    return this.deduplicatePermissions(allPermissions);
  }

  /**
   * Resolve permission conditions with user context
   */
  private resolveConditions(
    conditions: Record<string, any> | undefined,
    context: AuthorizationContext
  ): Record<string, any> | undefined {
    if (!conditions) {
      return undefined;
    }

    return this.interpolateVariables(conditions, {
      user: {
        id: context.userId,
        roles: context.roles,
        ...context.attributes,
      },
    });
  }

  /**
   * Interpolate template variables in conditions with security validation
   */
  private interpolateVariables(obj: any, variables: Record<string, any>): any {
    if (typeof obj === "string") {
      // Replace ${variable.path} patterns with security checks
      return obj.replace(/\$\{([a-zA-Z0-9_.]+)\}/g, (match, path) => {
        // Validate path format to prevent injection
        if (!/^[a-zA-Z0-9_.]+$/.test(path)) {
          this.logger.warn("Invalid template path detected", {
            path: path.substring(0, 50), // Limit logged path length
          });
          return match;
        }

        // Check for dangerous property names
        const dangerousProps = [
          "__proto__",
          "constructor",
          "prototype",
          "__defineGetter__",
          "__defineSetter__",
        ];
        const parts = path.split(".");
        if (parts.some((part: string) => dangerousProps.includes(part))) {
          this.logger.warn("Dangerous template path detected", {
            path: path.substring(0, 50),
          });
          return match;
        }

        // Limit depth to prevent deep object traversal attacks
        if (parts.length > this.constants.MAX_TEMPLATE_DEPTH) {
          this.logger.warn("Template path too deep", {
            path: path.substring(0, 50),
            depth: parts.length,
          });
          return match;
        }

        const value = this.getNestedValue(variables, path);
        // Convert to string and sanitize to prevent injection
        return value !== undefined ? String(value) : match;
      });
    }

    if (Array.isArray(obj)) {
      return obj.map((item) => this.interpolateVariables(item, variables));
    }

    if (obj && typeof obj === "object") {
      const result: Record<string, any> = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = this.interpolateVariables(value, variables);
      }
      return result;
    }

    return obj;
  }

  /**
   * Get nested value from object using dot notation
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split(".").reduce((current, key) => current?.[key], obj);
  }

  /**
   * Apply additional contextual permissions
   */
  private applyContextualPermissions(
    can: any,
    context: AuthorizationContext
  ): void {
    // Apply session-based permissions
    if (context.sessionId) {
      can("read", "Session", { id: context.sessionId });
      can("delete", "Session", { userId: context.userId });
    }

    // Apply IP-based restrictions if needed
    if (this.config.strictMode && context.ipAddress) {
      // Add IP-based restrictions for sensitive operations
      // This is an example - implement based on your security requirements
    }
  }

  /**
   * Remove duplicate permissions and resolve conflicts
   */
  private deduplicatePermissions(permissions: Permission[]): Permission[] {
    const seen = new Map<string, Permission>();

    for (const permission of permissions) {
      const existing = seen.get(permission.id);

      if (!existing) {
        seen.set(permission.id, permission);
      } else {
        // Handle conflicts - more permissive wins unless explicitly denied
        if (permission.inverted && !existing.inverted) {
          seen.set(permission.id, permission); // Denial takes precedence
        } else if (!permission.inverted && !existing.inverted) {
          // Merge fields if both are grants
          const mergedFields = [
            ...(existing.fields || []),
            ...(permission.fields || []),
          ];
          const uniqueFields =
            mergedFields.length > 0 ? [...new Set(mergedFields)] : undefined;

          seen.set(permission.id, {
            ...existing,
            fields: uniqueFields,
          });
        }
      }
    }

    return Array.from(seen.values());
  }

  /**
   * Generate secure cache key for user context
   */
  private getCacheKey(context: AuthorizationContext): string {
    const data = {
      userId: context.userId,
      roles: context.roles.sort(),
      sessionId: context.sessionId, // Include session for uniqueness
      timestamp: Math.floor(
        Date.now() / this.constants.CACHE_ROTATION_INTERVAL_MS
      ), // Cache rotation
    };

    // Use crypto hash instead of predictable base64 encoding
    const hash = createHash("sha256")
      .update(JSON.stringify(data))
      .digest("hex")
      .substring(0, 16); // Use first 16 chars for efficiency

    return `ability:${hash}`;
  }

  /**
   * Check if cached ability is still valid
   */
  private isCacheValid(timestamp: number): boolean {
    return Date.now() - timestamp < this.config.cacheTimeout;
  }

  /**
   * Clear cached abilities using CacheService pattern matching
   */
  async clearCache(userId?: string): Promise<void> {
    if (!this.config.enableCaching || !this.cacheService) {
      this.logger.debug(
        "Cache clearing skipped - caching disabled or no cache service"
      );
      return;
    }

    try {
      let pattern: string;

      if (userId) {
        // Create pattern to match specific user's abilities
        // Since we base64 encode the userId in getCacheKey, we need to find all keys containing this user
        const userPattern = Buffer.from(userId).toString("base64");
        pattern = `ability:*${userPattern}*`;
      } else {
        // Clear all abilities
        pattern = "ability:*";
      }

      const clearedCount = await this.cacheService.invalidatePattern(pattern);

      this.logger.info("Ability cache cleared", {
        userId: userId ? `${userId.substring(0, 8)}***` : "all",
        clearedCount,
      });

      this.metrics?.recordCounter("authorization.ability.cache_cleared", 1, {
        userId: userId || "all",
        clearedCount: clearedCount.toString(),
      });
    } catch (error) {
      this.logger.error("Failed to clear ability cache", {
        error: error instanceof Error ? error.message : "Unknown error",
        userId: userId ? `${userId.substring(0, 8)}***` : "all",
      });

      this.metrics?.recordCounter(
        "authorization.ability.cache_clear_error",
        1,
        {
          userId: userId || "all",
        }
      );
    }
  }

  /**
   * Get cache statistics from CacheService
   */
  getCacheStats(): {
    enabled: boolean;
    hasCacheService: boolean;
    pendingComputations: number;
    serviceStats?: any;
  } {
    const stats = {
      enabled: this.config.enableCaching,
      hasCacheService: !!this.cacheService,
      pendingComputations: this.pendingComputations.size,
    };

    if (this.cacheService) {
      try {
        const serviceStats = this.cacheService.getStats();
        return {
          ...stats,
          serviceStats,
        };
      } catch (error) {
        this.logger.warn("Failed to get cache service stats", {
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    return stats;
  }

  /**
   * Health check for ability factory
   */
  async healthCheck(): Promise<{
    status: "healthy" | "degraded" | "unhealthy";
    details: any;
  }> {
    const details: any = {
      caching: this.config.enableCaching,
      pendingComputations: this.pendingComputations.size,
    };

    try {
      if (this.cacheService) {
        const cacheHealth = await this.cacheService.healthCheck();
        details.cache = cacheHealth;

        if (cacheHealth.status === "critical") {
          return {
            status: "degraded",
            details: {
              ...details,
              issue: "Cache service is in critical state",
            },
          };
        }
      }

      return {
        status: "healthy",
        details,
      };
    } catch (error) {
      return {
        status: "unhealthy",
        details: {
          ...details,
          error: error instanceof Error ? error.message : "Unknown error",
        },
      };
    }
  }

  /**
   * Get permission changes for granular cache updates
   */
  getPermissionChanges(
    oldPermissions: Permission[],
    newPermissions: Permission[]
  ): {
    added: Permission[];
    removed: Permission[];
    modified: Permission[];
  } {
    const oldMap = new Map(oldPermissions.map((p) => [p.id, p]));
    const newMap = new Map(newPermissions.map((p) => [p.id, p]));

    const added: Permission[] = [];
    const removed: Permission[] = [];
    const modified: Permission[] = [];

    // Find added and modified permissions
    for (const [id, newPerm] of newMap) {
      const oldPerm = oldMap.get(id);
      if (!oldPerm) {
        added.push(newPerm);
      } else if (JSON.stringify(oldPerm) !== JSON.stringify(newPerm)) {
        modified.push(newPerm);
      }
    }

    // Find removed permissions
    for (const [id, oldPerm] of oldMap) {
      if (!newMap.has(id)) {
        removed.push(oldPerm);
      }
    }

    return { added, removed, modified };
  }

  /**
   * Cleanup method for proper lifecycle management
   */
  async cleanup(): Promise<void> {
    try {
      // Clear cleanup interval
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = undefined;
      }

      // Clear all pending computations and their timeouts
      for (const [, computation] of this.pendingComputations) {
        clearTimeout(computation.timeout);
      }
      this.pendingComputations.clear();

      this.logger.info("AbilityFactory cleanup completed");
    } catch (error) {
      this.logger.error("Failed to cleanup AbilityFactory", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }
}
