// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = "postgresql://postgres:TEST@localhost:5432/neurotracker?schema=public"
  // env("DATABASE_URL")
}

// generator repository {
//   provider = "prisma-repository-generator"
//   // Add any specific options for the generator here
// }

// generator zod {
//   provider = "prisma-zod-generator"
// }

// generator repo {
//   provider = "prisma-repo"
//   output   = "../src/repository"
//   query    = true
//   warn     = true
//   info     = true
//   error    = true
// }

enum StoreStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

model Store {
  id             String            @id @default(cuid())
  name           String            @db.VarChar(255)
  url            String            @unique @db.VarChar(255)
  ownerId        String
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  deletedAt      DateTime?
  isDeleted      Boolean           @default(false)
  status         StoreStatus       @default(ACTIVE)
  settings       StoreSettings?
  users          User[]
  carts          Cart[]
  products       Product[]
  sessions       UserSession[]
  recoveryEvents RecoveryEvent[]
  webhooks       Webhook[]
  reports        Report[]
  activities     SessionActivity[]
  apiKeys        ApiKey[] // API keys associated with this store

  @@index([ownerId])
  @@map("stores")
}

enum EventType {
  LOGIN
  LOGOUT
  CART_CREATED
  CART_UPDATED
  CART_ABANDONED
  ORDER_PLACED
  ORDER_COMPLETED
  FEATURE_COMPUTED
  EXPORT_REQUESTED
  QUALITY_ALERT
  RECONCILIATION_RUN
  OTHER
}

enum UserRoleType {
  ADMIN
  ANALYST
  VIEWER
  USER
}

model StoreSettings {
  id        String   @id @default(cuid())
  storeId   String   @unique
  config    Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@map("store_settings")
}

model RecoveryEvent {
  id        String         @id @default(cuid())
  cartId    String
  storeId   String
  userId    String?
  sessionId String?
  eventType String         @db.VarChar(128)
  status    RecoveryStatus @default(PENDING)
  outcome   String?
  metadata  Json?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  cart    Cart         @relation(fields: [cartId], references: [id], onDelete: Cascade)
  store   Store        @relation(fields: [storeId], references: [id], onDelete: Cascade)
  user    User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  session UserSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([eventType])
  @@index([status])
  @@map("recovery_events")
}

enum RecoveryStatus {
  PENDING
  SUCCESS
  FAILED
  IGNORED
}

model Report {
  id          String       @id @default(cuid())
  storeId     String
  type        String       @db.VarChar(64)
  status      ReportStatus @default(PENDING)
  data        Json?
  url         String?
  generatedAt DateTime?
  error       String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([type])
  @@index([status])
  @@map("reports")
}

enum ReportStatus {
  PENDING
  PROCESSING
  READY
  FAILED
}

model SessionActivity {
  id        String   @id @default(cuid())
  sessionId String
  storeId   String
  activity  String   @db.VarChar(128)
  timestamp DateTime @default(now())
  metadata  Json?

  session UserSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  store   Store       @relation(fields: [storeId], references: [id], onDelete: Cascade)
  User    User[]

  @@index([activity])
  @@map("session_activities")
}

model Webhook {
  id            String    @id @default(cuid())
  storeId       String
  url           String    @db.VarChar(255)
  eventType     String    @db.VarChar(128)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastTriggered DateTime?
  metadata      Json?

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([eventType])
  @@map("webhooks")
}

// Enterprise RBAC Role Model - Phase 3A Architecture
model Role {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(128)
  displayName String   @db.VarChar(255)
  description String?
  category    String   @default("functional") @db.VarChar(64)
  level       Int      @default(5) // RoleLevel enum as integer
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  version     String   @default("1.0.0") @db.VarChar(32)
  metadata    Json?

  // Proper self-referential role hierarchy
  parentRoleId String?
  parentRole   Role?   @relation("RoleHierarchy", fields: [parentRoleId], references: [id], onDelete: SetNull)
  childRoles   Role[]  @relation("RoleHierarchy")

  // Legacy fields for backward compatibility (will be removed after migration)
  parentRoleIds String[] @default([])
  childRoleIds  String[] @default([])

  // Relations
  users       User[]
  permissions RolePermission[]

  @@index([name])
  @@index([category])
  @@index([isActive])
  @@index([parentRoleId])
  @@map("roles")
}

// Permission model for RBAC
model RolePermission {
  id       String @id @default(cuid())
  roleId   String
  resource String @db.VarChar(128)
  action   String @db.VarChar(128)

  // Permission metadata
  name        String  @db.VarChar(128)
  description String?
  conditions  Json? // PermissionCondition[] serialized
  metadata    Json? // PermissionMetadata serialized
  priority    String  @default("medium") @db.VarChar(32)
  version     String  @default("1.0.0") @db.VarChar(32)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([roleId, resource, action])
  @@index([resource])
  @@index([action])
  @@map("role_permissions")
}

// Updated User model for Phase 3A single role architecture
model User {
  id             String     @id @default(cuid())
  email          String     @unique @db.VarChar(255)
  password       String     @db.VarChar(255)
  username       String     @unique @db.VarChar(255)
  firstName      String?    @db.VarChar(255)
  lastName       String?    @db.VarChar(255)
  phone          String?    @db.VarChar(32)
  status         UserStatus @default(ACTIVE)
  emailVerified  Boolean    @default(false)
  phoneVerified  Boolean    @default(false)
  lastLoginAt    DateTime?
  loginCount     Int        @default(0)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  deletedAt      DateTime?
  isDeleted      Boolean    @default(false)
  createdBy      String?
  updatedBy      String?
  organizationId String?
  auditLog       Json? // Audit field for compliance

  // Phase 3A: Single role architecture with audit tracking
  roleId         String?
  role           Role?     @relation(fields: [roleId], references: [id], onDelete: SetNull)
  roleAssignedAt DateTime? // When current role was assigned
  roleRevokedAt  DateTime? // When role was revoked (null = active)
  roleAssignedBy String? // User ID who assigned the role
  roleRevokedBy  String? // User ID who revoked the role
  roleExpiresAt  DateTime? // Optional role expiration

  // Additional metadata
  metadata Json? // Store custom attributes and storeId

  // Relations
  sessions       UserSession[]
  events         UserEvent[]
  carts          Cart[]
  notifications  Notification[]
  orders         Order[]
  storeId        String?
  store          Store?            @relation(fields: [storeId], references: [id])
  recoveryEvents RecoveryEvent[]
  activities     SessionActivity[]
  apiKeys        ApiKey[] // API keys owned by this user

  @@index([email])
  @@index([username])
  @@index([status])
  @@index([roleId])
  @@map("users")
}

enum UserStatus {
  ACTIVE
  BANNED
  INACTIVE
  DELETED
}

model UserSession {
  id        String    @id @default(cuid())
  userId    String
  sessionId String    @unique @db.VarChar(128)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime?
  ipAddress String?
  userAgent String?
  metadata  Json?
  isActive  Boolean   @default(true)
  endedAt   DateTime?

  // Relations
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  events          UserEvent[]
  logs            SessionLog[]
  Store           Store[]
  RecoveryEvent   RecoveryEvent[]
  SessionActivity SessionActivity[]

  @@index([sessionId])
  @@map("user_sessions")
}

model SessionLog {
  id        String   @id @default(cuid())
  sessionId String
  event     String   @db.VarChar(128)
  timestamp DateTime @default(now())
  metadata  Json?

  session UserSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([event])
  @@map("session_logs")
}

model UserEvent {
  id        String   @id @default(cuid())
  userId    String
  sessionId String?
  eventType String   @db.VarChar(128)
  timestamp DateTime @default(now())
  metadata  Json?
  pageUrl   String?
  userAgent String?
  ipAddress String?
  isError   Boolean  @default(false)
  errorMsg  String?

  // Relations
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  session UserSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([eventType])
  @@map("user_events")
}

model Product {
  id          String        @id @default(cuid())
  name        String        @db.VarChar(255)
  description String?
  price       Decimal
  currency    String        @default("USD")
  sku         String?       @unique @db.VarChar(128)
  imageUrl    String?
  category    String?
  status      ProductStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  deletedAt   DateTime?
  isDeleted   Boolean       @default(false)
  createdBy   String?
  updatedBy   String?
  metadata    Json?

  // Relations
  cartItems  CartItem[]
  orderItems OrderItem[]
  Store      Store[]

  @@index([sku])
  @@map("products")
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
  DELETED
}

model Cart {
  id        String     @id @default(cuid())
  userId    String
  status    CartStatus @default(ACTIVE)
  total     Decimal    @default(0)
  currency  String     @default("USD")
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  deletedAt DateTime?
  isDeleted Boolean    @default(false)
  archived  Boolean    @default(false)
  metadata  Json?
  auditLog  Json? // Audit field for compliance

  // Relations
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  items         CartItem[]
  features      Feature[]
  orders        Order[]
  Store         Store[]
  RecoveryEvent RecoveryEvent[]

  @@index([status])
  @@index([userId])
  @@map("carts")
}

model Order {
  id          String      @id @default(cuid())
  cartId      String
  userId      String
  status      OrderStatus @default(PENDING)
  total       Decimal
  currency    String      @default("USD")
  paymentId   String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  completedAt DateTime?
  cancelledAt DateTime?
  metadata    Json?

  // Relations
  cart     Cart        @relation(fields: [cartId], references: [id], onDelete: Cascade)
  user     User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items    OrderItem[]
  payments Payment[]

  @@index([status])
  @@map("orders")
}

enum OrderStatus {
  PENDING
  COMPLETED
  CANCELLED
  FAILED
}

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  productId String
  quantity  Int      @default(1)
  price     Decimal
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([orderId, productId])
  @@map("order_items")
}

model Payment {
  id            String        @id @default(cuid())
  orderId       String
  amount        Decimal
  currency      String        @default("USD")
  status        PaymentStatus @default(PENDING)
  provider      String?
  transactionId String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  completedAt   DateTime?
  failedAt      DateTime?
  metadata      Json?

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([status])
  @@map("payments")
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model CartItem {
  id        String   @id @default(cuid())
  cartId    String
  productId String
  quantity  Int      @default(1)
  price     Decimal
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  metadata  Json?

  // Relations
  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([cartId, productId])
  @@map("cart_items")
}

model Feature {
  id          String   @id @default(cuid())
  cartId      String
  name        String   @db.VarChar(128)
  value       Json
  version     String   @default("1.0.0") @db.VarChar(32)
  description String?
  ttl         Int? // Time-to-live in seconds (optional)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  metadata    Json?

  // Relations
  cart Cart? @relation(fields: [cartId], references: [id], onDelete: Cascade)

  @@unique([cartId, name], name: "cartId_name")
  @@index([version])
  @@map("features")
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  type      String    @db.VarChar(64)
  message   String
  read      Boolean   @default(false)
  createdAt DateTime  @default(now())
  readAt    DateTime?
  metadata  Json?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([type])
  @@map("notifications")
}

model Config {
  id          String   @id @default(cuid())
  key         String   @unique @db.VarChar(128)
  value       Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  description String?

  @@map("config")
}

enum CartStatus {
  ACTIVE
  ABANDONED
  CONVERTED
  EXPIRED
}

model QualityValidation {
  id        String   @id @default(uuid())
  table     String
  check     String
  status    String // e.g., "passed", "failed"
  timestamp DateTime @default(now())
}

model QualityAnomaly {
  id        String   @id @default(uuid())
  type      String // e.g., "outlier", "missing", "duplicate"
  details   Json?
  timestamp DateTime @default(now())
}

model ReconciliationRule {
  id            String                    @id @default(uuid())
  name          String
  sourceTable   String
  targetTable   String
  joinKey       String
  enabled       Boolean                   @default(true)
  sourceColumns String?
  targetColumns String?
  tolerance     Float?
  createdAt     DateTime                  @default(now())
  executions    ReconciliationExecution[]
}

model ReconciliationExecution {
  id             String             @id @default(uuid())
  ruleId         String
  status         String
  recordsChecked Int
  discrepancies  Int
  executedAt     DateTime           @default(now())
  executionTime  Float
  details        String?
  rule           ReconciliationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
}

model RepairOperation {
  id          String   @id @default(uuid())
  operationId String
  type        String
  status      String
  error       String?
  executedAt  DateTime @default(now())
}

// API Key model for authentication
model ApiKey {
  id         String  @id @default(cuid())
  name       String  @db.VarChar(255)
  keyHash    String  @unique @db.VarChar(255) // Hashed API key
  keyPreview String  @db.VarChar(16) // First few chars for display
  userId     String
  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  storeId    String?
  store      Store?  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  // Permissions and scope
  permissions Json? // Array of permissions
  scopes      String[] // API scopes/endpoints allowed

  // Usage tracking
  lastUsedAt DateTime?
  usageCount Int       @default(0)

  // Status and lifecycle
  isActive  Boolean   @default(true)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  revokedAt DateTime?
  revokedBy String? // User ID who revoked the key

  // Metadata for additional context
  metadata Json?

  @@index([keyHash])
  @@index([userId])
  @@index([storeId])
  @@index([isActive])
  @@map("api_keys")
}
