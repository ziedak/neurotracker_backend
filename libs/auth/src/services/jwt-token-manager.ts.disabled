/**
 * JWT Token Manager - Enterprise Token Lifecycle Orchestration
 *
 * Features:
 * - Complete token lifecycle management
 * - Integration with enhanced JWT service and session management
 * - Automatic token rotation and refresh
 * - Security policy enforcement
 * - Token analytics and monitoring
 * - Multi-factor authentication token handling
 */

import { Logger, MetricsCollector } from "@libs/monitoring";
/*
import {
  EnhancedJWTService,
  TokenValidationResult,
  SecurityLevel,
} from "./enhanced-jwt-service";
*/
import {
  JWTBlacklistManager,
  TokenRevocationReason,
} from "./jwt-blacklist-manager";
import { UnifiedSessionManager } from "./unified-session-manager";
import {
  SessionAuthMethod,
  SessionProtocol,
  SessionStatus,
  SessionData,
} from "../models/session-models";
import { JWTPayload } from "../jwt";

// Temporary extensions until enhanced-jwt-service is implemented
interface ExtendedJWTPayload extends JWTPayload {
  jti?: string;
  sessionId?: string;
  securityLevel?: SecurityLevel;
}

// Temporary types until enhanced-jwt-service is implemented
enum SecurityLevel {
  LOW = "LOW",
  MEDIUM = "MEDIUM",
  HIGH = "HIGH",
  CRITICAL = "CRITICAL",
}

interface TokenValidationResult {
  valid: boolean;
  payload?: ExtendedJWTPayload;
  error?: string;
  securityLevel?: SecurityLevel;
  securityInfo?: {
    validationTime?: number;
  };
}

// Temporary placeholder class until enhanced-jwt-service is implemented
class EnhancedJWTService {
  // Placeholder methods
  generateFingerprint(context: any): string {
    return "placeholder-fingerprint";
  }

  async generateEnhancedTokens(context: any): Promise<any> {
    return {
      accessToken: "placeholder-token",
      refreshToken: "placeholder-refresh",
    };
  }

  async validateToken(
    token: string,
    context: any
  ): Promise<TokenValidationResult> {
    return { valid: false, error: "Enhanced JWT Service not implemented yet" };
  }

  async revokeToken(
    token: string,
    reason: TokenRevocationReason,
    revokedBy: string
  ): Promise<void> {
    // Placeholder implementation
  }

  async revokeUserTokens(
    userId: string,
    reason: TokenRevocationReason,
    revokedBy: string
  ): Promise<number> {
    return 0;
  }
}

/**
 * Token lifecycle events
 */
export enum TokenLifecycleEvent {
  CREATED = "created",
  VALIDATED = "validated",
  REFRESHED = "refreshed",
  REVOKED = "revoked",
  EXPIRED = "expired",
  SECURITY_VIOLATION = "security_violation",
}

/**
 * Token creation context with comprehensive metadata
 */
export interface TokenCreationContext {
  readonly userId: string;
  readonly userEmail: string;
  readonly roles: string[];
  readonly permissions: string[];
  readonly storeId?: string;
  readonly deviceInfo?: {
    readonly userAgent?: string;
    readonly ipAddress?: string;
    readonly acceptLanguage?: string;
    readonly timezone?: string;
    readonly deviceType?: "desktop" | "mobile" | "tablet" | "api";
  };
  readonly securityContext?: {
    readonly securityLevel?: SecurityLevel;
    readonly mfaVerified?: boolean;
    readonly trustedDevice?: boolean;
    readonly riskScore?: number;
  };
  readonly sessionInfo?: {
    readonly sessionId?: string;
    readonly protocol?: SessionProtocol;
    readonly origin?: string;
    readonly connectionId?: string;
  };
  readonly metadata?: Record<string, unknown>;
}

/**
 * Token validation context for comprehensive security checks
 */
export interface TokenValidationContext {
  readonly fingerprint?: string;
  readonly requiredSecurityLevel?: SecurityLevel;
  readonly audience?: string;
  readonly issuer?: string;
  readonly expectedUserId?: string;
  readonly expectedSessionId?: string;
  readonly deviceInfo?: {
    readonly userAgent?: string;
    readonly ipAddress?: string;
  };
}

/**
 * Token rotation policy configuration
 */
export interface TokenRotationPolicy {
  readonly enabled: boolean;
  readonly rotationIntervalHours: number;
  readonly gracePeriodMinutes: number;
  readonly maxConcurrentTokens: number;
  readonly rotateOnSecurityEvent: boolean;
}

/**
 * JWT token manager configuration
 */
export interface JWTTokenManagerConfig {
  readonly rotation: TokenRotationPolicy;
  readonly security: {
    readonly enforceFingerprinting: boolean;
    readonly requireSessionValidation: boolean;
    readonly enableSecurityAnalytics: boolean;
    readonly maxTokensPerUser: number;
  };
  readonly monitoring: {
    readonly enableDetailedLogging: boolean;
    readonly enableMetrics: boolean;
    readonly enableAuditing: boolean;
  };
  readonly integration: {
    readonly enableSessionSync: boolean;
    readonly enableAutomaticCleanup: boolean;
    readonly cleanupIntervalHours: number;
  };
}

/**
 * Default token manager configuration
 */
export const DEFAULT_TOKEN_MANAGER_CONFIG: JWTTokenManagerConfig = {
  rotation: {
    enabled: process.env.JWT_ROTATION_ENABLED === "true",
    rotationIntervalHours: parseInt(
      process.env.JWT_ROTATION_INTERVAL_HOURS || "24"
    ),
    gracePeriodMinutes: parseInt(
      process.env.JWT_ROTATION_GRACE_PERIOD_MINUTES || "15"
    ),
    maxConcurrentTokens: parseInt(process.env.JWT_MAX_CONCURRENT_TOKENS || "3"),
    rotateOnSecurityEvent: process.env.JWT_ROTATE_ON_SECURITY_EVENT !== "false",
  },
  security: {
    enforceFingerprinting: process.env.JWT_ENFORCE_FINGERPRINTING === "true",
    requireSessionValidation:
      process.env.JWT_REQUIRE_SESSION_VALIDATION === "true",
    enableSecurityAnalytics:
      process.env.JWT_ENABLE_SECURITY_ANALYTICS !== "false",
    maxTokensPerUser: parseInt(process.env.JWT_MAX_TOKENS_PER_USER || "10"),
  },
  monitoring: {
    enableDetailedLogging: process.env.JWT_DETAILED_LOGGING !== "false",
    enableMetrics: process.env.JWT_ENABLE_METRICS !== "false",
    enableAuditing: process.env.JWT_ENABLE_AUDITING === "true",
  },
  integration: {
    enableSessionSync: process.env.JWT_ENABLE_SESSION_SYNC !== "false",
    enableAutomaticCleanup: process.env.JWT_ENABLE_AUTO_CLEANUP !== "false",
    cleanupIntervalHours: parseInt(
      process.env.JWT_CLEANUP_INTERVAL_HOURS || "6"
    ),
  },
};

/**
 * Token creation result with comprehensive information
 */
export interface TokenCreationResult {
  readonly accessToken: string;
  readonly refreshToken: string;
  readonly tokenId: string;
  readonly expiresIn: number;
  readonly expiresAt: Date;
  readonly sessionId?: string;
  readonly securityInfo: {
    readonly securityLevel: SecurityLevel;
    readonly fingerprint?: string;
    readonly mfaVerified: boolean;
    readonly trustedDevice: boolean;
  };
}

/**
 * Token refresh result
 */
export interface TokenRefreshResult {
  readonly accessToken: string;
  readonly refreshToken?: string; // New refresh token if rotation is enabled
  readonly tokenId: string;
  readonly expiresIn: number;
  readonly rotated: boolean;
}

/**
 * Token analytics information
 */
export interface TokenAnalytics {
  readonly totalActiveTokens: number;
  readonly tokensBySecurityLevel: Record<SecurityLevel, number>;
  readonly tokensByDevice: Record<string, number>;
  readonly recentEvents: Array<{
    readonly event: TokenLifecycleEvent;
    readonly timestamp: Date;
    readonly userId: string;
    readonly tokenId: string;
    readonly details?: Record<string, unknown>;
  }>;
}

/**
 * Token lifecycle event handler
 */
class TokenLifecycleHandler {
  private readonly logger: Logger;
  private readonly metrics: MetricsCollector;

  constructor(logger: Logger, metrics: MetricsCollector) {
    this.logger = logger.child({ component: "TokenLifecycleHandler" });
    this.metrics = metrics;
  }

  /**
   * Handle token lifecycle events
   */
  async handleEvent(
    event: TokenLifecycleEvent,
    tokenId: string,
    userId: string,
    details: Record<string, unknown> = {}
  ): Promise<void> {
    try {
      // Log the event
      this.logger.info(`Token lifecycle event: ${event}`, {
        event,
        tokenId,
        userId,
        ...details,
      });

      // Record metrics
      await this.metrics.recordCounter(`token_lifecycle_${event}`);

      // Record detailed metrics based on event type
      switch (event) {
        case TokenLifecycleEvent.CREATED:
          await this.metrics.recordCounter("token_created_total");
          if (details.securityLevel) {
            await this.metrics.recordCounter(
              `token_created_${details.securityLevel}`
            );
          }
          break;

        case TokenLifecycleEvent.VALIDATED:
          await this.metrics.recordCounter("token_validated_total");
          if (details.validationTime) {
            await this.metrics.recordTimer(
              "token_validation_duration",
              details.validationTime as number
            );
          }
          break;

        case TokenLifecycleEvent.SECURITY_VIOLATION:
          await this.metrics.recordCounter("token_security_violation_total");
          if (details.violationType) {
            await this.metrics.recordCounter(
              `token_security_violation_${details.violationType}`
            );
          }
          break;

        case TokenLifecycleEvent.REVOKED:
          await this.metrics.recordCounter("token_revoked_total");
          if (details.reason) {
            await this.metrics.recordCounter(`token_revoked_${details.reason}`);
          }
          break;
      }
    } catch (error) {
      this.logger.error(
        "Failed to handle token lifecycle event",
        error as Error,
        {
          event,
          tokenId,
          userId,
        }
      );
    }
  }
}

/**
 * Session integration helper for token-session coordination
 */
class SessionIntegrationHelper {
  private readonly logger: Logger;
  private readonly sessionManager: UnifiedSessionManager;

  constructor(sessionManager: UnifiedSessionManager, logger: Logger) {
    this.sessionManager = sessionManager;
    this.logger = logger.child({ component: "SessionIntegrationHelper" });
  }

  /**
   * Create session for token
   */
  async createTokenSession(
    context: TokenCreationContext,
    tokenId: string,
    expiresAt: Date
  ): Promise<string> {
    try {
      const sessionData = await this.sessionManager.createSession(
        context.userId,
        {
          protocol: context.sessionInfo?.protocol || SessionProtocol.HTTP,
          authMethod: SessionAuthMethod.JWT,
          ipAddress: context.deviceInfo?.ipAddress,
          userAgent: context.deviceInfo?.userAgent,
          origin: context.sessionInfo?.origin,
          connectionId: context.sessionInfo?.connectionId,
          expirationHours: Math.ceil(
            (expiresAt.getTime() - Date.now()) / (1000 * 60 * 60)
          ),
          deviceInfo: {
            deviceId: tokenId,
            deviceType:
              context.deviceInfo?.deviceType === "api"
                ? "server"
                : context.deviceInfo?.deviceType,
            os: this.extractOSFromUserAgent(context.deviceInfo?.userAgent),
            browser: this.extractBrowserFromUserAgent(
              context.deviceInfo?.userAgent
            ),
          },
          metadata: {
            customData: {
              tokenId,
              securityLevel: context.securityContext?.securityLevel,
              mfaVerified: context.securityContext?.mfaVerified,
              trustedDevice: context.securityContext?.trustedDevice,
              ...context.metadata,
            },
          },
        }
      );

      return sessionData.sessionId;
    } catch (error) {
      this.logger.error("Failed to create token session", error as Error, {
        userId: context.userId,
        tokenId,
      });
      throw error;
    }
  }

  /**
   * Validate token session
   */
  async validateTokenSession(
    sessionId: string,
    tokenId: string
  ): Promise<boolean> {
    try {
      const sessionData = await this.sessionManager.getSession(sessionId);

      if (!sessionData) {
        return false;
      }

      // Check if session is active and matches token
      if (sessionData.status !== SessionStatus.ACTIVE) {
        return false;
      }

      // Verify token association
      const sessionTokenId = sessionData.metadata?.customData?.tokenId;
      if (sessionTokenId !== tokenId) {
        return false;
      }

      return true;
    } catch (error) {
      this.logger.warn("Session validation failed", {
        sessionId,
        tokenId,
        error,
      });
      return false;
    }
  }

  /**
   * Update session on token refresh
   */
  async updateSessionForTokenRefresh(
    sessionId: string,
    newTokenId: string
  ): Promise<void> {
    try {
      await this.sessionManager.updateSession(sessionId, {
        lastActivity: new Date(),
        metadata: {
          customData: {
            tokenId: newTokenId,
            lastRefresh: new Date().toISOString(),
          },
        },
      });
    } catch (error) {
      this.logger.warn("Failed to update session for token refresh", {
        sessionId,
        newTokenId,
        error,
      });
    }
  }

  /**
   * Clean up session when token is revoked
   */
  async cleanupTokenSession(sessionId: string): Promise<void> {
    try {
      await this.sessionManager.deleteSession(sessionId);
      this.logger.debug("Token session cleaned up", { sessionId });
    } catch (error) {
      this.logger.warn("Failed to cleanup token session", { sessionId, error });
    }
  }

  // Private helper methods

  private extractOSFromUserAgent(userAgent?: string): string {
    if (!userAgent) return "Unknown";

    if (userAgent.includes("Windows")) return "Windows";
    if (userAgent.includes("Mac")) return "macOS";
    if (userAgent.includes("Linux")) return "Linux";
    if (userAgent.includes("Android")) return "Android";
    if (userAgent.includes("iOS")) return "iOS";

    return "Unknown";
  }

  private extractBrowserFromUserAgent(userAgent?: string): string {
    if (!userAgent) return "Unknown";

    if (userAgent.includes("Chrome")) return "Chrome";
    if (userAgent.includes("Firefox")) return "Firefox";
    if (userAgent.includes("Safari")) return "Safari";
    if (userAgent.includes("Edge")) return "Edge";

    return "Unknown";
  }
}

/**
 * JWT Token Manager - Enterprise Token Lifecycle Management
 *
 * Orchestrates token creation, validation, refresh, and revocation
 * with comprehensive security features and session integration
 */
export class JWTTokenManager {
  private readonly logger: Logger;
  private readonly metrics: MetricsCollector;
  private readonly config: JWTTokenManagerConfig;
  private readonly enhancedJWTService: EnhancedJWTService;
  private readonly blacklistManager: JWTBlacklistManager;
  private readonly sessionManager: UnifiedSessionManager;
  private readonly lifecycleHandler: TokenLifecycleHandler;
  private readonly sessionIntegration: SessionIntegrationHelper;
  private cleanupTimer?: NodeJS.Timeout;
  private isInitialized = false;

  constructor(
    config: Partial<JWTTokenManagerConfig> = {},
    logger: Logger,
    metrics: MetricsCollector,
    enhancedJWTService: EnhancedJWTService,
    blacklistManager: JWTBlacklistManager,
    sessionManager: UnifiedSessionManager
  ) {
    this.config = { ...DEFAULT_TOKEN_MANAGER_CONFIG, ...config };
    this.logger = logger.child({ component: "JWTTokenManager" });
    this.metrics = metrics;
    this.enhancedJWTService = enhancedJWTService;
    this.blacklistManager = blacklistManager;
    this.sessionManager = sessionManager;

    // Initialize helpers
    this.lifecycleHandler = new TokenLifecycleHandler(
      this.logger,
      this.metrics
    );
    this.sessionIntegration = new SessionIntegrationHelper(
      this.sessionManager,
      this.logger
    );
  }

  /**
   * Initialize the token manager
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    const startTime = Date.now();

    try {
      // Start automatic cleanup if enabled
      if (this.config.integration.enableAutomaticCleanup) {
        this.startCleanupTimer();
      }

      this.isInitialized = true;
      const duration = Date.now() - startTime;

      this.logger.info("JWT token manager initialized", { duration });
      await this.metrics.recordTimer("token_manager_init_duration", duration);
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(
        "Failed to initialize JWT token manager",
        error as Error,
        { duration }
      );
      await this.metrics.recordCounter("token_manager_init_error");
      throw error;
    }
  }

  /**
   * Create tokens with comprehensive security and session integration
   */
  async createTokens(
    context: TokenCreationContext
  ): Promise<TokenCreationResult> {
    await this.ensureInitialized();

    const startTime = Date.now();

    try {
      // Build base JWT payload
      const primaryRole = context.roles[0] || "customer";
      const validRole = [
        "admin",
        "store_owner",
        "api_user",
        "customer",
      ].includes(primaryRole)
        ? (primaryRole as "admin" | "store_owner" | "api_user" | "customer")
        : "customer";

      const basePayload: Omit<JWTPayload, "iat" | "exp"> = {
        sub: context.userId,
        email: context.userEmail,
        storeId: context.storeId,
        role: validRole,
        permissions: context.permissions,
      };

      // Generate fingerprint if required
      let fingerprint: string | undefined;
      if (this.config.security.enforceFingerprinting && context.deviceInfo) {
        fingerprint = this.enhancedJWTService.generateFingerprint({
          userAgent: context.deviceInfo.userAgent,
          ipAddress: context.deviceInfo.ipAddress,
          acceptLanguage: context.deviceInfo.acceptLanguage,
          timezone: context.deviceInfo.timezone,
        });
      }

      // Create tokens
      const tokenResult = await this.enhancedJWTService.generateEnhancedTokens(
        basePayload,
        {
          fingerprint,
          sessionId: context.sessionInfo?.sessionId,
          securityLevel:
            context.securityContext?.securityLevel || SecurityLevel.MEDIUM,
          customClaims: context.metadata,
          audience: this.config.security.enforceFingerprinting
            ? "authenticated-client"
            : undefined,
        }
      );

      let sessionId: string | undefined;

      // Create session if integration is enabled
      if (this.config.integration.enableSessionSync) {
        try {
          sessionId = await this.sessionIntegration.createTokenSession(
            context,
            tokenResult.tokenId,
            new Date(tokenResult.expiresIn * 1000)
          );
        } catch (sessionError) {
          this.logger.warn("Failed to create session for token", {
            tokenId: tokenResult.tokenId,
            userId: context.userId,
            error: sessionError,
          });
        }
      }

      // Handle lifecycle event
      await this.lifecycleHandler.handleEvent(
        TokenLifecycleEvent.CREATED,
        tokenResult.tokenId,
        context.userId,
        {
          securityLevel: context.securityContext?.securityLevel,
          mfaVerified: context.securityContext?.mfaVerified,
          trustedDevice: context.securityContext?.trustedDevice,
          deviceType:
            context.deviceInfo?.deviceType === "api"
              ? "server"
              : context.deviceInfo?.deviceType,
          sessionId,
        }
      );

      const duration = Date.now() - startTime;

      this.logger.info("Tokens created successfully", {
        tokenId: tokenResult.tokenId,
        userId: context.userId,
        sessionId,
        duration,
      });

      return {
        accessToken: tokenResult.accessToken,
        refreshToken: tokenResult.refreshToken,
        tokenId: tokenResult.tokenId,
        expiresIn: tokenResult.expiresIn,
        expiresAt: new Date(tokenResult.expiresIn * 1000),
        sessionId,
        securityInfo: {
          securityLevel:
            context.securityContext?.securityLevel || SecurityLevel.MEDIUM,
          fingerprint,
          mfaVerified: context.securityContext?.mfaVerified || false,
          trustedDevice: context.securityContext?.trustedDevice || false,
        },
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      this.logger.error("Failed to create tokens", error as Error, {
        userId: context.userId,
        duration,
      });

      await this.metrics.recordTimer("token_create_error_duration", duration);
      await this.metrics.recordCounter("token_create_error");
      throw error;
    }
  }

  /**
   * Validate token with comprehensive security checks
   */
  async validateToken(
    token: string,
    context: TokenValidationContext = {}
  ): Promise<TokenValidationResult> {
    await this.ensureInitialized();

    const startTime = Date.now();

    try {
      // Perform enhanced validation
      const validationResult = await this.enhancedJWTService.validateToken(
        token,
        {
          fingerprint: context.fingerprint,
          requiredSecurityLevel: context.requiredSecurityLevel,
          audience: context.audience,
          issuer: context.issuer,
        }
      );

      if (!validationResult.isValid) {
        // Handle lifecycle event for failed validation
        if (validationResult.error) {
          await this.lifecycleHandler.handleEvent(
            TokenLifecycleEvent.SECURITY_VIOLATION,
            "unknown",
            context.expectedUserId || "unknown",
            {
              violationType: validationResult.error,
              fingerprint: context.fingerprint,
            }
          );
        }

        const duration = Date.now() - startTime;
        await this.metrics.recordTimer(
          "token_validate_failed_duration",
          duration
        );
        return validationResult;
      }

      const payload = validationResult.payload!;

      // Additional context validation
      if (context.expectedUserId && payload.sub !== context.expectedUserId) {
        await this.lifecycleHandler.handleEvent(
          TokenLifecycleEvent.SECURITY_VIOLATION,
          payload.jti,
          payload.sub,
          { violationType: "user_mismatch" }
        );

        const duration = Date.now() - startTime;
        await this.metrics.recordTimer(
          "token_validate_user_mismatch_duration",
          duration
        );

        return {
          isValid: false,
          error: "user_mismatch" as any,
          securityInfo: validationResult.securityInfo,
        };
      }

      // Session validation if required
      if (this.config.security.requireSessionValidation && payload.sessionId) {
        const sessionValid = await this.sessionIntegration.validateTokenSession(
          payload.sessionId,
          payload.jti
        );

        if (!sessionValid) {
          await this.lifecycleHandler.handleEvent(
            TokenLifecycleEvent.SECURITY_VIOLATION,
            payload.jti,
            payload.sub,
            { violationType: "session_invalid" }
          );

          const duration = Date.now() - startTime;
          await this.metrics.recordTimer(
            "token_validate_session_invalid_duration",
            duration
          );

          return {
            isValid: false,
            error: "session_invalid" as any,
            securityInfo: validationResult.securityInfo,
          };
        }
      }

      // Handle successful validation event
      await this.lifecycleHandler.handleEvent(
        TokenLifecycleEvent.VALIDATED,
        payload.jti,
        payload.sub,
        {
          securityLevel: payload.securityLevel,
          validationTime: validationResult.securityInfo?.validationTime,
        }
      );

      const duration = Date.now() - startTime;
      await this.metrics.recordTimer(
        "token_validate_success_duration",
        duration
      );
      return validationResult;
    } catch (error) {
      const duration = Date.now() - startTime;

      this.logger.error("Token validation failed", error as Error, {
        expectedUserId: context.expectedUserId,
        duration,
      });

      await this.metrics.recordTimer("token_validate_error_duration", duration);
      await this.metrics.recordCounter("token_validate_error");
      throw error;
    }
  }

  /**
   * Revoke token with session cleanup
   */
  async revokeToken(
    token: string,
    reason: TokenRevocationReason,
    revokedBy?: string
  ): Promise<void> {
    await this.ensureInitialized();

    const startTime = Date.now();

    try {
      // Extract token info before revoking
      const validationResult = await this.enhancedJWTService.validateToken(
        token,
        {}
      );

      // Revoke the token
      await this.enhancedJWTService.revokeToken(token, reason, revokedBy);

      // Clean up session if present and integration is enabled
      if (
        this.config.integration.enableSessionSync &&
        validationResult.isValid &&
        validationResult.payload?.sessionId
      ) {
        await this.sessionIntegration.cleanupTokenSession(
          validationResult.payload.sessionId
        );
      }

      // Handle lifecycle event
      if (validationResult.isValid && validationResult.payload) {
        await this.lifecycleHandler.handleEvent(
          TokenLifecycleEvent.REVOKED,
          validationResult.payload.jti,
          validationResult.payload.sub,
          { reason, revokedBy }
        );
      }

      const duration = Date.now() - startTime;

      this.logger.info("Token revoked successfully", {
        reason,
        revokedBy,
        duration,
      });

      await this.metrics.recordTimer("token_revoke_duration", duration);
      await this.metrics.recordCounter("token_revoke_success");
    } catch (error) {
      const duration = Date.now() - startTime;

      this.logger.error("Failed to revoke token", error as Error, {
        reason,
        revokedBy,
        duration,
      });

      await this.metrics.recordTimer("token_revoke_error_duration", duration);
      await this.metrics.recordCounter("token_revoke_error");
      throw error;
    }
  }

  /**
   * Revoke all tokens for a user
   */
  async revokeUserTokens(
    userId: string,
    reason: TokenRevocationReason,
    revokedBy?: string
  ): Promise<number> {
    await this.ensureInitialized();

    const startTime = Date.now();

    try {
      // Revoke tokens
      const revokedCount = await this.enhancedJWTService.revokeUserTokens(
        userId,
        reason,
        revokedBy
      );

      // Clean up user sessions if integration is enabled
      if (this.config.integration.enableSessionSync) {
        try {
          const userSessions = await this.sessionManager.getUserSessions(
            userId
          );
          await Promise.all(
            userSessions.map((sessionId) =>
              this.sessionIntegration.cleanupTokenSession(sessionId)
            )
          );
        } catch (sessionError) {
          this.logger.warn("Failed to cleanup user sessions", {
            userId,
            error: sessionError,
          });
        }
      }

      // Handle lifecycle event
      await this.lifecycleHandler.handleEvent(
        TokenLifecycleEvent.REVOKED,
        "user-tokens",
        userId,
        { reason, revokedBy, revokedCount }
      );

      const duration = Date.now() - startTime;

      this.logger.info("User tokens revoked successfully", {
        userId,
        revokedCount,
        reason,
        revokedBy,
        duration,
      });

      await this.metrics.recordTimer("token_revoke_user_duration", duration);
      await this.metrics.recordCounter("token_revoke_user_success");

      return revokedCount;
    } catch (error) {
      const duration = Date.now() - startTime;

      this.logger.error("Failed to revoke user tokens", error as Error, {
        userId,
        reason,
        revokedBy,
        duration,
      });

      await this.metrics.recordTimer(
        "token_revoke_user_error_duration",
        duration
      );
      await this.metrics.recordCounter("token_revoke_user_error");
      throw error;
    }
  }

  /**
   * Perform cleanup of expired tokens and sessions
   */
  async performCleanup(): Promise<{
    blacklistCleanup: number;
    sessionCleanup: { redis: number; postgresql: number };
  }> {
    await this.ensureInitialized();

    const startTime = Date.now();

    try {
      // Clean up blacklist
      const blacklistCleanup =
        await this.blacklistManager.cleanupExpiredEntries();

      // Clean up sessions
      const sessionCleanup = await this.sessionManager.cleanupExpiredSessions();

      const duration = Date.now() - startTime;

      this.logger.info("Cleanup completed successfully", {
        blacklistCleanup,
        sessionCleanup,
        duration,
      });

      await this.metrics.recordTimer("token_cleanup_duration", duration);
      await this.metrics.recordGauge(
        "token_cleanup_blacklist_entries",
        blacklistCleanup
      );
      await this.metrics.recordGauge(
        "token_cleanup_session_redis",
        sessionCleanup.redis
      );
      await this.metrics.recordGauge(
        "token_cleanup_session_postgresql",
        sessionCleanup.postgresql
      );

      return { blacklistCleanup, sessionCleanup };
    } catch (error) {
      const duration = Date.now() - startTime;

      this.logger.error("Cleanup failed", error as Error, { duration });
      await this.metrics.recordTimer("token_cleanup_error_duration", duration);
      await this.metrics.recordCounter("token_cleanup_error");
      throw error;
    }
  }

  /**
   * Graceful shutdown
   */
  async shutdown(): Promise<void> {
    this.logger.info("Shutting down JWT token manager");

    // Clear cleanup timer
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = undefined;
    }

    this.isInitialized = false;
    this.logger.info("JWT token manager shutdown complete");
  }

  // Private helper methods

  private async ensureInitialized(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }

  private startCleanupTimer(): void {
    this.cleanupTimer = setInterval(async () => {
      try {
        await this.performCleanup();
      } catch (error) {
        this.logger.error("Scheduled cleanup failed", error as Error);
      }
    }, this.config.integration.cleanupIntervalHours * 60 * 60 * 1000);

    this.logger.info("Automatic cleanup timer started", {
      intervalHours: this.config.integration.cleanupIntervalHours,
    });
  }
}
